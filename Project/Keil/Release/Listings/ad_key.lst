C51 COMPILER V9.60.7.0   AD_KEY                                                            07/11/2025 11:11:29 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE AD_KEY
OBJECT MODULE PLACED IN .\Release\Objects\ad_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\ad_key.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X000C
                    -) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Releas
                    -e\Listings\ad_key.lst) OBJECT(.\Release\Objects\ad_key.obj)

line level    source

   1          #include "ad_key.h"
   2          
   3          #if AD_KEY_ENABLE
   4          
   5          // 自定义ad按键的键值:
   6          // enum
   7          // {
   8          //     AD_KEY_ID_ONE_LEFT = 0x01,
   9          //     AD_KEY_ID_TWO_LEFT,
  10          //     AD_KEY_ID_THREE_LEFT,
  11          //     AD_KEY_ID_ONE_RIGHT,
  12          //     AD_KEY_ID_TWO_RIGHT,
  13          //     AD_KEY_ID_THREE_RIGHT,
  14          // };
  15          
  16          // 定义按键扫描函数中，各个扫描状态：
  17          // enum
  18          // {
  19          //     AD_KEY_SCAN_STATUS_NONE,                  // 空状态，检测是否有按键按下
  20          //     AD_KEY_SCAN_STATUS_IS_DETECT_LOOG_PRESS,  // 正在检测是否为长按（要跟检测长按作区
             -分）
  21          //     AD_KEY_SCAN_STATUS_IS_HANDLE_LONG_PRESS,  // 正在处理长按
  22          //     AD_KEY_SCAN_STATUS_IS_HANDLE_HOLD_PRESS,  // 正在处理长按持续（不松手）
  23          //     AD_KEY_SCAN_STATUS_IS_HANDLE_SHORT_PRESS, // 正在处理短按
  24          
  25          //     AD_KEY_SCAN_STATUS_IS_WAIT_SHORT_PRESS_RELEASE, // 正在等待短按松开
  26          //     AD_KEY_SCAN_STATUS_IS_WAIT_LONG_PRESS_RELEASE,  // 正在等待长按松开
  27          //     AD_KEY_SCAN_STATUS_IS_END,                      // 收尾处理
  28          // };
  29          // static volatile u8 ad_key_scan_status = 0; // 非阻塞的按键扫描函数中，使用的状态机
  30          
  31          // 存放按键对应的ad值:
  32          static const u16 ad_key_scan_table[][2] = {
  33              // [][0]按键对应的标号,在判断按键键值时使用   [][1]按键对应的ad值
  34              // {AD_KEY_ID_ONE_LEFT, AD_KEY_ONE_LEFT_VAL},
  35              // {AD_KEY_ID_TWO_LEFT, AD_KEY_TWO_LEFT_VAL},
  36              // {AD_KEY_ID_THREE_LEFT, AD_KEY_THREE_LEFT_VAL},
  37              // {AD_KEY_ID_ONE_RIGHT, AD_KEY_ONE_RIGHT_VAL},
  38              // {AD_KEY_ID_TWO_RIGHT, AD_KEY_TWO_RIGHT_VAL},
  39              // {AD_KEY_ID_THREE_RIGHT, AD_KEY_THREE_RIGHT_VAL},
  40          
  41              {AD_KEY_ID_1, AD_KEY_ID_1_VAL}, // 339
  42              {AD_KEY_ID_2, AD_KEY_ID_2_VAL}, // 1140
  43              {AD_KEY_ID_3, AD_KEY_ID_3_VAL}, // 1875
  44              {AD_KEY_ID_4, AD_KEY_ID_4_VAL}, // 2333
  45              {AD_KEY_ID_5, AD_KEY_ID_5_VAL}, // 3309
  46          };
  47          
  48          // 定义ad按键的按键事件
  49          enum AD_KEY_EVENT
  50          {
  51              AD_KEY_EVENT_NONE,
  52              AD_KEY_EVENT_ID_1_CLICK,
C51 COMPILER V9.60.7.0   AD_KEY                                                            07/11/2025 11:11:29 PAGE 2   

  53              AD_KEY_EVENT_ID_1_DOUBLE,
  54              AD_KEY_EVENT_ID_1_LONG,
  55              AD_KEY_EVENT_ID_1_HOLD,
  56              AD_KEY_EVENT_ID_1_LOOSE,
  57          
  58              AD_KEY_EVENT_ID_2_CLICK,
  59              AD_KEY_EVENT_ID_2_DOUBLE,
  60              AD_KEY_EVENT_ID_2_LONG,
  61              AD_KEY_EVENT_ID_2_HOLD,
  62              AD_KEY_EVENT_ID_2_LOOSE,
  63          
  64              AD_KEY_EVENT_ID_3_CLICK,
  65              AD_KEY_EVENT_ID_3_DOUBLE,
  66              AD_KEY_EVENT_ID_3_LONG,
  67              AD_KEY_EVENT_ID_3_HOLD,
  68              AD_KEY_EVENT_ID_3_LOOSE,
  69          
  70              AD_KEY_EVENT_ID_4_CLICK,
  71              AD_KEY_EVENT_ID_4_DOUBLE,
  72              AD_KEY_EVENT_ID_4_LONG,
  73              AD_KEY_EVENT_ID_4_HOLD,
  74              AD_KEY_EVENT_ID_4_LOOSE,
  75          
  76              AD_KEY_EVENT_ID_5_CLICK,
  77              AD_KEY_EVENT_ID_5_DOUBLE,
  78              AD_KEY_EVENT_ID_5_LONG,
  79              AD_KEY_EVENT_ID_5_HOLD,
  80              AD_KEY_EVENT_ID_5_LOOSE,
  81          };
  82          
  83          #define AD_KEY_EFFECT_EVENT_NUMS (5) // 单个ad按键的有效按键事件个数
  84          // 将按键id和按键事件绑定起来，在 xx 函数中，通过查表的方式得到按键事件
  85          static const u8 ad_key_event_table[][AD_KEY_EFFECT_EVENT_NUMS + 1] = {
  86              // [0]--按键对应的id号，用于查表，[1]、[2]、[3]...--用于与 key_driver.h 中定义的
             -键事件KEY_EVENT绑定关系(一定要一一对应)
  87              {AD_KEY_ID_1, AD_KEY_EVENT_ID_1_CLICK, AD_KEY_EVENT_ID_1_DOUBLE, AD_KEY_EVENT_ID_1_LONG, AD_KEY_EVENT_
             -ID_1_HOLD, AD_KEY_EVENT_ID_1_LOOSE}, //
  88              {AD_KEY_ID_2, AD_KEY_EVENT_ID_2_CLICK, AD_KEY_EVENT_ID_2_DOUBLE, AD_KEY_EVENT_ID_2_LONG, AD_KEY_EVENT_
             -ID_2_HOLD, AD_KEY_EVENT_ID_2_LOOSE}, //
  89              {AD_KEY_ID_3, AD_KEY_EVENT_ID_3_CLICK, AD_KEY_EVENT_ID_3_DOUBLE, AD_KEY_EVENT_ID_3_LONG, AD_KEY_EVENT_
             -ID_3_HOLD, AD_KEY_EVENT_ID_3_LOOSE}, //
  90              {AD_KEY_ID_4, AD_KEY_EVENT_ID_4_CLICK, AD_KEY_EVENT_ID_4_DOUBLE, AD_KEY_EVENT_ID_4_LONG, AD_KEY_EVENT_
             -ID_4_HOLD, AD_KEY_EVENT_ID_4_LOOSE}, //
  91              {AD_KEY_ID_5, AD_KEY_EVENT_ID_5_CLICK, AD_KEY_EVENT_ID_5_DOUBLE, AD_KEY_EVENT_ID_5_LONG, AD_KEY_EVENT_
             -ID_5_HOLD, AD_KEY_EVENT_ID_5_LOOSE}, //
  92          };
  93          
  94          extern u8 ad_key_get_key_id(void);
  95          // volatile key_driver_para_t ad_key_para = {
  96          volatile struct key_driver_para ad_key_para = {
  97              // 编译器不支持指定成员赋值的写法，会报错：
  98              // .scan_times = 10,   // 扫描频率，单位：ms
  99              // .last_key = NO_KEY, // 上一次得到的按键键值，初始化为无效的键值
 100              // // .filter_value = NO_KEY, // 按键消抖期间得到的键值(在key_driver_scan()函数中使用
             -)，初始化为 NO_KEY
 101              // // .filter_cnt = 0, // 按键消抖期间的累加值(在key_driver_scan()函数中使用)，初始
             -化为0
 102              // .filter_time = 3,       // 按键消抖次数，与扫描频率有关
 103              // .long_time = 50,        // 判定按键是长按对应的数量，与扫描频率有关
 104              // .hold_time = (75 + 15), // 判定按键是HOLD对应的数量，与扫描频率有关
 105              // // .press_cnt = 0, // 与long_time和hold_time对比, 判断长按事件和HOLD事件
 106              // // .click_cnt = 0,
C51 COMPILER V9.60.7.0   AD_KEY                                                            07/11/2025 11:11:29 PAGE 3   

 107              // .click_delay_time = 20, // 按键抬起后，等待连击的数量，与扫描频率有关
 108              // // .notify_value = 0,
 109              // .key_type = KEY_TYPE_AD, // 按键类型为ad按键
 110              // .get_value = ad_key_get_key_id,
 111          
 112              // .latest_key_val = AD_KEY_ID_NONE,
 113              // .latest_key_event = KEY_EVENT_NONE,
 114          
 115              AD_KEY_SCAN_CIRCLE_TIMES,
 116              0,
 117              // NO_KEY,
 118              0,
 119          
 120              0,
 121              0,
 122              3,
 123          
 124              AD_KEY_LONG_PRESS_TIME_THRESHOLD_MS / AD_KEY_SCAN_CIRCLE_TIMES,
 125              (AD_KEY_LONG_PRESS_TIME_THRESHOLD_MS + AD_KEY_HOLD_PRESS_TIME_THRESHOLD_MS) / AD_KEY_SCAN_CIRCLE_TIMES
             -,
 126              0,
 127          
 128              0,
 129              0,
 130              // 200 / AD_KEY_SCAN_CIRCLE_TIMES,
 131              0,
 132              // NO_KEY,
 133              0,
 134              KEY_TYPE_AD,
 135              ad_key_get_key_id,
 136          
 137              AD_KEY_ID_NONE,
 138              KEY_EVENT_NONE,
 139          };
 140          
 141          // 将采集到的ad值转换成自定义的键值
 142          static u16 __conver_cur_ad_to_ad_key(const u16 cur_ad_key)
 143          {
 144   1          u8 i = 0;
 145   1          // u16 ad_key_id = AD_KEY_ID_NONE;
 146   1          u16 ad_key_id = NO_KEY;
 147   1      
 148   1          // ARRAY_SIZE(ad_key_scan_table) 这里是求出数组中存放的按键个数
 149   1          for (i = 0; i < ARRAY_SIZE(ad_key_scan_table); i++)
 150   1          {
 151   2              // if (cur_ad_key > (ad_key_scan_table[i][1] - AD_KEY_INTERVAL) &&
 152   2              //     cur_ad_key < (ad_key_scan_table[i][1] + AD_KEY_INTERVAL))
 153   2              // {
 154   2              //     // 如果之前未检测到按键，现在检测到按键按下
 155   2              //     ad_key_id = ad_key_scan_table[i][0]; // 获取ad值对应的键值
 156   2              //     break;
 157   2              // }
 158   2      
 159   2              if (cur_ad_key < ad_key_scan_table[i][1])
 160   2              {
 161   3                  ad_key_id = ad_key_scan_table[i][0];
 162   3                  break;
 163   3              }
 164   2          }
 165   1      
 166   1          return ad_key_id;
 167   1      }
C51 COMPILER V9.60.7.0   AD_KEY                                                            07/11/2025 11:11:29 PAGE 4   

 168          
 169          //
 170          /**
 171           * @brief 将按键值和key_driver_scan得到的按键事件转换成ad按键的事件
 172           *
 173           * @param key_val ad按键键值
 174           * @param key_event 在key_driver_scan得到的按键事件 KEY_EVENT
 175           * @return u8 在ad_key_event_table中找到的对应的按键事件，如果没有则返回 AD_KEY_EVENT_
             -NONE
 176           */
 177          static u8 __ad_key_get_event(const u8 key_val, const u8 key_event)
 178          {
 179   1          u8 ret_key_event = AD_KEY_EVENT_NONE;
 180   1          u8 i = 0;
 181   1          for (; i < ARRAY_SIZE(ad_key_event_table); i++)
 182   1          {
 183   2              if (key_val == ad_key_event_table[i][0])
 184   2              {
 185   3                  // 如果往 KEY_EVENT 枚举中添加了新的按键事件，这里查表的方法就会失
             -，需要手动修改
 186   3                  ret_key_event = ad_key_event_table[i][key_event];
 187   3      
 188   3                  // if (KEY_EVENT_CLICK == key_event)
 189   3                  // {
 190   3                  //     ret_key_event = ad_key_event_table[i][1];
 191   3                  // }
 192   3                  // else if (KEY_EVENT_DOUBLE_CLICK == key_event)
 193   3                  // {
 194   3                  //     ret_key_event = ad_key_event_table[i][2];
 195   3                  // }
 196   3      
 197   3                  break;
 198   3              }
 199   2          }
 200   1      
 201   1          return ret_key_event;
 202   1      }
 203          
 204          u8 ad_key_get_key_id(void)
 205          {
 206   1          volatile u16 ad_key_id = 0;       // 单次按键标志
 207   1          adc_sel_pin(ADC_PIN_KEY);         // 内部至少占用1ms
 208   1          ad_key_id = adc_single_convert(); // 直接用单次转换,不取平均值,防止识别不到按键
 209   1          // printf("ad key val %u \n", ad_key_id);
 210   1          // printf("ad_key_id val %u\n", ad_key_id);
 211   1          ad_key_id = __conver_cur_ad_to_ad_key(ad_key_id); // 将采集到的ad值转换成自定义的键值
 212   1      
 213   1          // 测试用：
 214   1          // if (ad_key_id != 0)
 215   1          // {
 216   1          //     printf("ad key id %u\n", ad_key_id);
 217   1          // }
 218   1      
 219   1          return ad_key_id;
 220   1      }
 221          
 222          void ad_key_handle(void)
 223          {
 224   1          u8 ad_key_event = AD_KEY_EVENT_NONE;
 225   1      
 226   1          if (ad_key_para.latest_key_val == AD_KEY_ID_NONE)
 227   1          {
C51 COMPILER V9.60.7.0   AD_KEY                                                            07/11/2025 11:11:29 PAGE 5   

 228   2              return;
 229   2          }
 230   1      
 231   1          ad_key_event = __ad_key_get_event(ad_key_para.latest_key_val, ad_key_para.latest_key_event);
 232   1          ad_key_para.latest_key_val = AD_KEY_ID_NONE;
 233   1          ad_key_para.latest_key_event = KEY_EVENT_NONE;
 234   1      
 235   1          switch (ad_key_event)
 236   1          {
 237   2      #if 1
 238   2      
 239   2          case AD_KEY_EVENT_ID_1_CLICK:
 240   2              // printf("key 1 click\n");
 241   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)AD_KEY_CLICK_MSG << 16 | KEY_LEFT_PRE);
 242   2              break;
 243   2      
 244   2          case AD_KEY_EVENT_ID_1_DOUBLE:
 245   2              // printf("key 1 double\n");
 246   2              break;
 247   2      
 248   2          case AD_KEY_EVENT_ID_1_LONG:
 249   2              // printf("key 1 long\n");
 250   2              break;
 251   2      
 252   2          case AD_KEY_EVENT_ID_1_HOLD:
 253   2              // printf("key 1 hold\n");
 254   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)AD_KEY_LONG_MSG << 16 | KEY_LEFT_PRE);
 255   2              break;
 256   2      
 257   2          case AD_KEY_EVENT_ID_1_LOOSE:
 258   2              // printf("key 1 loose\n");
 259   2              break;
 260   2          case AD_KEY_EVENT_ID_2_CLICK:
 261   2              // printf("key 2 click\n");
 262   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)AD_KEY_CLICK_MSG << 16 | KEY_DOWN_VOL_DOWN);
 263   2              break;
 264   2      
 265   2          case AD_KEY_EVENT_ID_2_DOUBLE:
 266   2              // printf("key 2 double\n");
 267   2              break;
 268   2      
 269   2          case AD_KEY_EVENT_ID_2_LONG:
 270   2              // printf("key 2 long\n");
 271   2              break;
 272   2      
 273   2          case AD_KEY_EVENT_ID_2_HOLD:
 274   2              // printf("key 2 hold\n");
 275   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)AD_KEY_LONG_MSG << 16 | KEY_DOWN_VOL_DOWN);
 276   2              break;
 277   2      
 278   2          case AD_KEY_EVENT_ID_2_LOOSE:
 279   2              // printf("key 2 loose\n");
 280   2              break;
 281   2          case AD_KEY_EVENT_ID_3_CLICK:
 282   2              // printf("key 3 click\n");
 283   2      
 284   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)AD_KEY_CLICK_MSG << 16 | KEY_UP_VOL_UP);
 285   2              break;
 286   2      
 287   2          case AD_KEY_EVENT_ID_3_DOUBLE:
 288   2              // printf("key 3 double\n");
 289   2              break;
C51 COMPILER V9.60.7.0   AD_KEY                                                            07/11/2025 11:11:29 PAGE 6   

 290   2      
 291   2          case AD_KEY_EVENT_ID_3_LONG:
 292   2              // printf("key 3 long\n");
 293   2              break;
 294   2      
 295   2          case AD_KEY_EVENT_ID_3_HOLD:
 296   2              // printf("key 3 hold\n");
 297   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)AD_KEY_LONG_MSG << 16 | KEY_UP_VOL_UP);
 298   2              break;
 299   2      
 300   2          case AD_KEY_EVENT_ID_3_LOOSE:
 301   2              // printf("key 3 loose\n");
 302   2              break;
 303   2          case AD_KEY_EVENT_ID_4_CLICK:
 304   2              // printf("key 4 click\n");
 305   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)AD_KEY_CLICK_MSG << 16 | KEY_ENTER_MENU);
 306   2              break;
 307   2      
 308   2          case AD_KEY_EVENT_ID_4_DOUBLE:
 309   2              // printf("key 4 double\n");
 310   2              break;
 311   2      
 312   2          case AD_KEY_EVENT_ID_4_LONG:
 313   2              // printf("key 4 long\n");
 314   2              break;
 315   2      
 316   2          case AD_KEY_EVENT_ID_4_HOLD:
 317   2              // printf("key 4 hold\n");
 318   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)AD_KEY_LONG_MSG << 16 | KEY_ENTER_MENU);
 319   2              break;
 320   2      
 321   2          case AD_KEY_EVENT_ID_4_LOOSE:
 322   2              // printf("key 4 loose\n");
 323   2              break;
 324   2          case AD_KEY_EVENT_ID_5_CLICK:
 325   2              // printf("key 5 click\n");
 326   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)AD_KEY_CLICK_MSG << 16 | KEY_RIGHT_NEXT);
 327   2              break;
 328   2      
 329   2          case AD_KEY_EVENT_ID_5_DOUBLE:
 330   2              // printf("key 5 double\n");
 331   2              break;
 332   2      
 333   2          case AD_KEY_EVENT_ID_5_LONG:
 334   2              // printf("key 5 long\n");
 335   2              break;
 336   2      
 337   2          case AD_KEY_EVENT_ID_5_HOLD:
 338   2              // printf("key 5 hold\n");
 339   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)AD_KEY_LONG_MSG << 16 | KEY_RIGHT_NEXT);
 340   2              break;
 341   2      
 342   2          case AD_KEY_EVENT_ID_5_LOOSE:
 343   2              // printf("key 5 loose\n");
 344   2              break;
 345   2      
 346   2          default:
 347   2              break;
 348   2      
 349   2      #endif
 350   2          }
 351   1      }
C51 COMPILER V9.60.7.0   AD_KEY                                                            07/11/2025 11:11:29 PAGE 7   

 352          
 353          #endif//  AD_KEY_ENABLE


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    362    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     69       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
