C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     08/02/2025 16:49:15 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE FUEL_CAPACITY
OBJECT MODULE PLACED IN .\Release\Objects\fuel_capacity.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\fuel_capacity.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR
                    -(0X000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.
                    -\Release\Listings\fuel_capacity.lst) OBJECT(.\Release\Objects\fuel_capacity.obj)

line level    source

   1          #include "fuel_capacity.h"
   2          
   3          #if FUEL_CAPACITY_SCAN_ENABLE
   4          
   5          volatile u32 fuel_capacity_scan_cnt = 0; // 扫描时间计数，在1ms定时器中断中累加
   6          
   7          /*
   8              标志位，（如果当前油量百分比与上一次的油量百分比不在同一个油量格数下
             -）
   9              是否要更新上一次的油量百分比
  10              由定时器置一，软件清零
  11          */
  12          volatile bit flag_update_fuel_gear = 0;
  13          /*
  14              标志位，是否让定时器累计累计要更新油量挡位的时间
  15              如果当前油量百分比与上一次的油量百分比不在同一个挡位，由软件置一，定
             -时器开始累计时间（flag_timer_scan_update_fuel_gear_cnt）
  16          */
  17          volatile bit flag_timer_scan_update_fuel_gear = 0;
  18          /*
  19              定时器扫描计数，累计要更新油量挡位的时间
  20              由定时器累加
  21          */
  22          volatile u16 timer_scan_update_fuel_gear_cnt = 0;
  23          
  24          // 滑动平均：
  25          #define SAMPLE_COUNT 20 // 样本计数
  26          static volatile u16 samples[SAMPLE_COUNT] = {0};
  27          static volatile u8 sample_index = 0;
  28          u16 get_filtered_adc(u16 adc_val)
  29          {
  30   1          u8 i = 0;
  31   1          u32 sum = 0;
  32   1          samples[sample_index++] = adc_val;
  33   1          if (sample_index >= SAMPLE_COUNT)
  34   1              sample_index = 0;
  35   1      
  36   1          for (i = 0; i < SAMPLE_COUNT; i++)
  37   1              sum += samples[i];
  38   1      
  39   1          return sum / SAMPLE_COUNT;
  40   1      }
  41          
  42          // 给滑动平均使用到的数组进行初始化
  43          void samples_init(u16 adc_val)
  44          {
  45   1          u8 i = 0;
  46   1          for (; i < SAMPLE_COUNT; i++)
  47   1          {
  48   2              samples[i] = adc_val;
  49   2          }
  50   1      }
  51          
C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     08/02/2025 16:49:15 PAGE 2   

  52          // 将油量检测对应的ad值转换成百分比值
  53          u8 convert_fuel_adc_to_percent(u16 fuel_adc_val)
  54          {
  55   1      
  56   1          u8 ret = 0;
  57   1      
  58   1          // 如果超出了 最大油量的ad值和最小油量的ad值之间的范围 ，说明没有接油量
             -检测
  59   1          if (fuel_adc_val >= (4095 - 500) ||
  60   1              fuel_adc_val <= (0 + 500))
  61   1          {
  62   2              ret = 0xFF; // 根据串口收发协议，0xFF对应没有接油量检测
  63   2          }
  64   1          else
  65   1          {
  66   2              if (fuel_adc_val > FUEL_LEVEL_0_ADC_VAL) // 如果检测到的ad值比最小油量对应的ad值
             -要大
  67   2              {
  68   3                  ret = 0; // 0% 油量
  69   3              }
  70   2              else if (fuel_adc_val <= FUEL_LEVEL_6_ADC_VAL) // 如果检测到的油量比100%还要大一些
  71   2              {
  72   3                  ret = 100;
  73   3              }
  74   2              else if (fuel_adc_val <= FUEL_LEVEL_0_ADC_VAL && fuel_adc_val > FUEL_LEVEL_1_ADC_VAL) /* 0格油
             -到1格油量，0% ~ 18% */
  75   2              {
  76   3                  /*
  77   3                      用采集到的ad值减去当前挡位最小的ad值，再除以（当前挡位最大的ad
             -值-当前挡位最小的ad值），得到
  78   3                      采集到的ad值对应当前挡位的占比，再乘以当前挡位对应的百分比
  79   3                  */
  80   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_1_ADC_VAL) * 18 / ((u32)FUEL_LEVEL_0_ADC_VAL - FUEL_LEVE
             -L_1_ADC_VAL);
  81   3                  ret = 18 - ret;
  82   3              }
  83   2              else if (fuel_adc_val <= FUEL_LEVEL_1_ADC_VAL && fuel_adc_val > FUEL_LEVEL_2_ADC_VAL) /* 1格油
             -到2格油量，18% ~ 34% */
  84   2              {
  85   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_2_ADC_VAL) * 34 / ((u32)FUEL_LEVEL_1_ADC_VAL - FUEL_LEVE
             -L_2_ADC_VAL);
  86   3                  ret = 34 - ret;
  87   3                  if (ret < 18)
  88   3                  {
  89   4                      ret = 18;
  90   4                  }
  91   3              }
  92   2              else if (fuel_adc_val <= FUEL_LEVEL_2_ADC_VAL && fuel_adc_val > FUEL_LEVEL_3_ADC_VAL) /* 2格油
             -到3格油量，34% ~ 51% */
  93   2              {
  94   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_3_ADC_VAL) * 51 / ((u32)FUEL_LEVEL_2_ADC_VAL - FUEL_LEVE
             -L_3_ADC_VAL);
  95   3                  ret = 51 - ret;
  96   3                  if (ret < 34)
  97   3                  {
  98   4                      ret = 34;
  99   4                  }
 100   3              }
 101   2              else if (fuel_adc_val <= FUEL_LEVEL_3_ADC_VAL && fuel_adc_val > FUEL_LEVEL_4_ADC_VAL) /* 3格油
             -到4格油量，51% ~ 68% */
 102   2              {
 103   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_4_ADC_VAL) * 68 / ((u32)FUEL_LEVEL_3_ADC_VAL - FUEL_LEVE
C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     08/02/2025 16:49:15 PAGE 3   

             -L_4_ADC_VAL);
 104   3                  ret = 68 - ret;
 105   3                  if (ret < 51)
 106   3                  {
 107   4                      ret = 51;
 108   4                  }
 109   3              }
 110   2              else if (fuel_adc_val <= FUEL_LEVEL_4_ADC_VAL && fuel_adc_val > FUEL_LEVEL_5_ADC_VAL) /* 4格油
             -到5格油量，68% ~ 84% */
 111   2              {
 112   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_5_ADC_VAL) * 84 / ((u32)FUEL_LEVEL_4_ADC_VAL - FUEL_LEVE
             -L_5_ADC_VAL);
 113   3                  ret = 84 - ret;
 114   3                  if (ret < 68)
 115   3                  {
 116   4                      ret = 68;
 117   4                  }
 118   3              }
 119   2              else if (fuel_adc_val <= FUEL_LEVEL_5_ADC_VAL && fuel_adc_val > FUEL_LEVEL_6_ADC_VAL) /* 5格油
             -到6格油量，84% ~ 100.0% */
 120   2              {
 121   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_6_ADC_VAL) * 100 / ((u32)FUEL_LEVEL_5_ADC_VAL - FUEL_LEV
             -EL_6_ADC_VAL);
 122   3                  ret = 100 - ret;
 123   3                  if (ret < 84)
 124   3                  {
 125   4                      ret = 84;
 126   4                  }
 127   3              }
 128   2          }
 129   1      
 130   1          // 0，显示0格，游标闪烁
 131   1          // 18以下，不含18，显示1格
 132   1          // ret = 18; // 18及以上，显示2格
 133   1          // ret = 34; // 34及以上，显示3格
 134   1          // ret = 51; // 51及以上，显示4格
 135   1          // ret = 68; // 68及以上，显示5格
 136   1          // ret = 84; // 84及以上，显示6格
 137   1          return ret;
 138   1      }
 139          
 140          u8 convert_fuel_percent_to_gear(u8 fuel_percent)
 141          {
 142   1          u8 fuel_gear = 0;
 143   1          if (0 == fuel_percent)
 144   1          {
 145   2              fuel_gear = 0;
 146   2          }
 147   1          else if (fuel_percent >= 1 && fuel_percent <= 17)
 148   1          {
 149   2              fuel_gear = 1;
 150   2          }
 151   1          else if (fuel_percent >= 18 && fuel_percent <= 33)
 152   1          {
 153   2              fuel_gear = 2;
 154   2          }
 155   1          else if (fuel_percent >= 34 && fuel_percent <= 50)
 156   1          {
 157   2              fuel_gear = 3;
 158   2          }
 159   1          else if (fuel_percent >= 51 && fuel_percent <= 67)
 160   1          {
C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     08/02/2025 16:49:15 PAGE 4   

 161   2              fuel_gear = 4;
 162   2          }
 163   1          else if (fuel_percent >= 68 && fuel_percent <= 83)
 164   1          {
 165   2              fuel_gear = 5;
 166   2          }
 167   1          // else if (fuel_percent >= 84)
 168   1          else
 169   1          {
 170   2              fuel_gear = 6;
 171   2          }
 172   1      
 173   1          return fuel_gear;
 174   1      }
 175          
 176          enum
 177          {
 178              STATUS_JUST_POWER_ON = 0, // 刚上电
 179              STATUS_IN_SERVICE,        // 运行中
 180          };
 181          
 182          // volatile u16 fuel_adc_val = 0; // DEBUG 测试用
 183          void fuel_capacity_scan(void)
 184          {
 185   1          u8 fuel_percent = 0;
 186   1          u16 fuel_adc_val = 0;
 187   1      
 188   1          /*
 189   1              记录上一次采集到的油量挡位
 190   1              用于控制每隔 40s 更新一次油量的格数，0~6格油量
 191   1          */
 192   1          static u8 fuel_gear = 0;
 193   1      
 194   1          // printf("fuel_adc_val: %u\n", fuel_adc_val);
 195   1      
 196   1          /*
 197   1              刚上电直接获取一次，作为油量的状态
 198   1          */
 199   1          {
 200   2              static u8 status = STATUS_JUST_POWER_ON;
 201   2              if (STATUS_JUST_POWER_ON == status) // 如果是第一次上电
 202   2              {
 203   3                  if (fuel_capacity_scan_cnt >= FUEL_UPDATE_TIME_WHEN_POWER_ON)
 204   3                  {
 205   4                      fuel_capacity_scan_cnt = 0;
 206   4                      adc_sel_pin(ADC_PIN_FUEL); // 内部至少占用1ms
 207   4                      adc_val = adc_getval();    //
 208   4                      samples_init(adc_val); // 滑动平均滤波初始化
 209   4                      fuel_adc_val = adc_val;
 210   4      
 211   4                      fuel_percent = convert_fuel_adc_to_percent(fuel_adc_val);
 212   4      
 213   4                      fuel_gear = convert_fuel_percent_to_gear(fuel_percent);
 214   4      
 215   4                      // printf("power on, fuel_percent:%bu\n", fuel_percent);
 216   4                      fun_info.fuel = fuel_percent;
 217   4                      fuel_adc_val = 0;
 218   4                      flag_get_fuel = 1;
 219   4      
 220   4                      status = STATUS_IN_SERVICE;
 221   4                  }
 222   3              }
C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     08/02/2025 16:49:15 PAGE 5   

 223   2          }
 224   1      
 225   1          adc_sel_pin(ADC_PIN_FUEL); // 内部至少占用1ms
 226   1          adc_val = adc_getval();    //
 227   1          fuel_adc_val = get_filtered_adc(adc_val);
 228   1      
 229   1          if (fuel_capacity_scan_cnt >= FUEL_UPDATE_TIME)
 230   1          {
 231   2              u8 cur_fuel_gear = 0;
 232   2              // 如果到了扫描更新时间
 233   2              fuel_capacity_scan_cnt = 0;
 234   2      
 235   2              fuel_percent = convert_fuel_adc_to_percent(fuel_adc_val);
 236   2              cur_fuel_gear = convert_fuel_percent_to_gear(fuel_percent);
 237   2      
 238   2              if (cur_fuel_gear != fuel_gear)
 239   2              {
 240   3                  flag_timer_scan_update_fuel_gear = 1;
 241   3              }
 242   2              else
 243   2              {
 244   3                  // 如果当前油量挡位与上一次的油量挡位相同
 245   3                  flag_timer_scan_update_fuel_gear = 0;
 246   3      
 247   3                  fun_info.fuel = fuel_percent;
 248   3                  flag_get_fuel = 1; // 发送油量百分比数据
 249   3              }
 250   2      
 251   2              // 如果更新油量的时间到来，也发送一次油量百分比数据，更新 last_fuel_per
             -cent
 252   2              if (flag_update_fuel_gear)
 253   2              {
 254   3                  flag_update_fuel_gear = 0;
 255   3      
 256   3      #if 1
 257   3                  // 每次更新油量百分比，只变化一个挡位；
 258   3                  // 只有当前油量百分比与上一次记录的油量百分比不同，且更新油量挡
             -的时间到来，才会进入
 259   3                  if (cur_fuel_gear != fuel_gear)
 260   3                  {
 261   4                      u8 i;
 262   4      
 263   4                      if (fuel_gear > cur_fuel_gear)
 264   4                      {
 265   5                          if (fuel_gear > 0)
 266   5                          {
 267   6                              fuel_gear--;
 268   6                          }
 269   5                      }
 270   4                      else
 271   4                      {
 272   5                          if (fuel_gear < 6)
 273   5                          {
 274   6                              fuel_gear++;
 275   6                          }
 276   5                      }
 277   4      
 278   4                      for (i = 0; i < 255; i++)
 279   4                      {
 280   5                          u8 tmp = convert_fuel_percent_to_gear(i);
 281   5                          if (tmp == fuel_gear)
 282   5                          {
C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     08/02/2025 16:49:15 PAGE 6   

 283   6                              fuel_percent = i; // 得到变化一个挡位后对应的油量百分比
 284   6                              break;
 285   6                          }
 286   5                      }
 287   4                  }
 288   3      #endif
 289   3      
 290   3                  fun_info.fuel = fuel_percent;
 291   3                  flag_get_fuel = 1; // 发送油量百分比数据
 292   3              }
 293   2      
 294   2              // printf("fuel_percent:%bu\n", fuel_percent);
 295   2              // fun_info.fuel = fuel_percent;
 296   2              // fuel_adc_val = 0;
 297   2              // flag_get_fuel = 1;
 298   2          } //  if (fuel_capacity_scan_cnt >= FUEL_UPDATE_TIME)
 299   1      }
 300          
 301          #endif // FUEL_CAPACITY_SCAN_ENABLE


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    977    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     49      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
