C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     07/31/2025 17:40:06 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE FUEL_CAPACITY
OBJECT MODULE PLACED IN .\Release\Objects\fuel_capacity.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\fuel_capacity.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR
                    -(0X000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.
                    -\Release\Listings\fuel_capacity.lst) OBJECT(.\Release\Objects\fuel_capacity.obj)

line level    source

   1          #include "fuel_capacity.h"
   2          
   3          volatile u32 fuel_capacity_scan_cnt = 0; // 扫描时间计数，在1ms定时器中断中累加
   4          
   5          /*
   6              标志位，（如果当前油量百分比与上一次的油量百分比不在同一个油量格数下
             -）
   7              是否要更新上一次的油量百分比
   8              由定时器置一，软件清零
   9          */
  10          volatile bit flag_update_fuel_gear = 0;
  11          /*
  12              标志位，是否让定时器累计累计要更新油量挡位的时间
  13              如果当前油量百分比与上一次的油量百分比不在同一个挡位，由软件置一，定
             -时器开始累计时间（flag_timer_scan_update_fuel_gear_cnt）
  14          */
  15          volatile bit flag_timer_scan_update_fuel_gear = 0;
  16          /*
  17              定时器扫描计数，累计要更新油量挡位的时间
  18              由定时器累加
  19          */
  20          volatile u16 timer_scan_update_fuel_gear_cnt = 0;
  21          
  22          // 滑动平均：
  23          #define SAMPLE_COUNT 20 // 样本计数
  24          static volatile u16 samples[SAMPLE_COUNT] = {0};
  25          static volatile u8 sample_index = 0;
  26          u16 get_filtered_adc(u16 adc_val)
  27          {
  28   1          u8 i = 0;
  29   1          u32 sum = 0;
  30   1          samples[sample_index++] = adc_val;
  31   1          if (sample_index >= SAMPLE_COUNT)
  32   1              sample_index = 0;
  33   1      
  34   1          for (i = 0; i < SAMPLE_COUNT; i++)
  35   1              sum += samples[i];
  36   1      
  37   1          return sum / SAMPLE_COUNT;
  38   1      }
  39          
  40          // 给滑动平均使用到的数组进行初始化
  41          void samples_init(u16 adc_val)
  42          {
  43   1          u8 i = 0;
  44   1          for (; i < SAMPLE_COUNT; i++)
  45   1          {
  46   2              samples[i] = adc_val;
  47   2          }
  48   1      }
  49          
  50          // 将油量检测对应的ad值转换成百分比值
  51          u8 convert_fuel_adc_to_percent(u16 fuel_adc_val)
C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     07/31/2025 17:40:06 PAGE 2   

  52          {
  53   1      
  54   1          u8 ret = 0;
  55   1      
  56   1          // 如果超出了 最大油量的ad值和最小油量的ad值之间的范围 ，说明没有接油量
             -检测
  57   1          if (fuel_adc_val >= (4095 - 500) ||
  58   1              fuel_adc_val <= (0 + 500))
  59   1          {
  60   2              ret = 0xFF; // 根据串口收发协议，0xFF对应没有接油量检测
  61   2          }
  62   1          else
  63   1          {
  64   2              if (fuel_adc_val > FUEL_LEVEL_0_ADC_VAL) // 如果检测到的ad值比最小油量对应的ad值
             -要大
  65   2              {
  66   3                  ret = 0; // 0% 油量
  67   3              }
  68   2              else if (fuel_adc_val <= FUEL_LEVEL_6_ADC_VAL) // 如果检测到的油量比100%还要大一些
  69   2              {
  70   3                  ret = 100;
  71   3              }
  72   2              else if (fuel_adc_val <= FUEL_LEVEL_0_ADC_VAL && fuel_adc_val > FUEL_LEVEL_1_ADC_VAL) /* 0格油
             -到1格油量，0% ~ 18% */
  73   2              {
  74   3                  /*
  75   3                      用采集到的ad值减去当前挡位最小的ad值，再除以（当前挡位最大的ad
             -值-当前挡位最小的ad值），得到
  76   3                      采集到的ad值对应当前挡位的占比，再乘以当前挡位对应的百分比
  77   3                  */
  78   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_1_ADC_VAL) * 18 / ((u32)FUEL_LEVEL_0_ADC_VAL - FUEL_LEVE
             -L_1_ADC_VAL);
  79   3                  ret = 18 - ret;
  80   3              }
  81   2              else if (fuel_adc_val <= FUEL_LEVEL_1_ADC_VAL && fuel_adc_val > FUEL_LEVEL_2_ADC_VAL) /* 1格油
             -到2格油量，18% ~ 34% */
  82   2              {
  83   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_2_ADC_VAL) * 34 / ((u32)FUEL_LEVEL_1_ADC_VAL - FUEL_LEVE
             -L_2_ADC_VAL);
  84   3                  ret = 34 - ret;
  85   3                  if (ret < 18)
  86   3                  {
  87   4                      ret = 18;
  88   4                  }
  89   3              }
  90   2              else if (fuel_adc_val <= FUEL_LEVEL_2_ADC_VAL && fuel_adc_val > FUEL_LEVEL_3_ADC_VAL) /* 2格油
             -到3格油量，34% ~ 51% */
  91   2              {
  92   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_3_ADC_VAL) * 51 / ((u32)FUEL_LEVEL_2_ADC_VAL - FUEL_LEVE
             -L_3_ADC_VAL);
  93   3                  ret = 51 - ret;
  94   3                  if (ret < 34)
  95   3                  {
  96   4                      ret = 34;
  97   4                  }
  98   3              }
  99   2              else if (fuel_adc_val <= FUEL_LEVEL_3_ADC_VAL && fuel_adc_val > FUEL_LEVEL_4_ADC_VAL) /* 3格油
             -到4格油量，51% ~ 68% */
 100   2              {
 101   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_4_ADC_VAL) * 68 / ((u32)FUEL_LEVEL_3_ADC_VAL - FUEL_LEVE
             -L_4_ADC_VAL);
 102   3                  ret = 68 - ret;
C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     07/31/2025 17:40:06 PAGE 3   

 103   3                  if (ret < 51)
 104   3                  {
 105   4                      ret = 51;
 106   4                  }
 107   3              }
 108   2              else if (fuel_adc_val <= FUEL_LEVEL_4_ADC_VAL && fuel_adc_val > FUEL_LEVEL_5_ADC_VAL) /* 4格油
             -到5格油量，68% ~ 84% */
 109   2              {
 110   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_5_ADC_VAL) * 84 / ((u32)FUEL_LEVEL_4_ADC_VAL - FUEL_LEVE
             -L_5_ADC_VAL);
 111   3                  ret = 84 - ret;
 112   3                  if (ret < 68)
 113   3                  {
 114   4                      ret = 68;
 115   4                  }
 116   3              }
 117   2              else if (fuel_adc_val <= FUEL_LEVEL_5_ADC_VAL && fuel_adc_val > FUEL_LEVEL_6_ADC_VAL) /* 5格油
             -到6格油量，84% ~ 100.0% */
 118   2              {
 119   3                  ret = ((u32)fuel_adc_val - FUEL_LEVEL_6_ADC_VAL) * 100 / ((u32)FUEL_LEVEL_5_ADC_VAL - FUEL_LEV
             -EL_6_ADC_VAL);
 120   3                  ret = 100 - ret;
 121   3                  if (ret < 84)
 122   3                  {
 123   4                      ret = 84;
 124   4                  }
 125   3              }
 126   2          }
 127   1      
 128   1          // 0，显示0格，游标闪烁
 129   1          // 18以下，不含18，显示1格
 130   1          // ret = 18; // 18及以上，显示2格
 131   1          // ret = 34; // 34及以上，显示3格
 132   1          // ret = 51; // 51及以上，显示4格
 133   1          // ret = 68; // 68及以上，显示5格
 134   1          // ret = 84; // 84及以上，显示6格
 135   1          return ret;
 136   1      }
 137          
 138          u8 convert_fuel_percent_to_gear(u8 fuel_percent)
 139          {
 140   1          u8 fuel_gear = 0;
 141   1          if (0 == fuel_percent)
 142   1          {
 143   2              fuel_gear = 0;
 144   2          }
 145   1          else if (fuel_percent >= 1 && fuel_percent <= 17)
 146   1          {
 147   2              fuel_gear = 1;
 148   2          }
 149   1          else if (fuel_percent >= 18 && fuel_percent <= 33)
 150   1          {
 151   2              fuel_gear = 2;
 152   2          }
 153   1          else if (fuel_percent >= 34 && fuel_percent <= 50)
 154   1          {
 155   2              fuel_gear = 3;
 156   2          }
 157   1          else if (fuel_percent >= 51 && fuel_percent <= 67)
 158   1          {
 159   2              fuel_gear = 4;
 160   2          }
C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     07/31/2025 17:40:06 PAGE 4   

 161   1          else if (fuel_percent >= 68 && fuel_percent <= 83)
 162   1          {
 163   2              fuel_gear = 5;
 164   2          }
 165   1          // else if (fuel_percent >= 84)
 166   1          else
 167   1          {
 168   2              fuel_gear = 6;
 169   2          }
 170   1      
 171   1          return fuel_gear;
 172   1      }
 173          
 174          enum
 175          {
 176              STATUS_JUST_POWER_ON = 0, // 刚上电
 177              STATUS_IN_SERVICE,        // 运行中
 178          };
 179          
 180          // volatile u16 fuel_adc_val = 0; // DEBUG 测试用
 181          void fuel_capacity_scan(void)
 182          {
 183   1          u8 fuel_percent = 0;
 184   1          u16 fuel_adc_val = 0;
 185   1      
 186   1          /*
 187   1              记录上一次采集到的油量挡位
 188   1              用于控制每隔 40s 更新一次油量的格数，0~6格油量
 189   1          */
 190   1          static u8 fuel_gear = 0;
 191   1      
 192   1          // printf("fuel_adc_val: %u\n", fuel_adc_val);
 193   1      
 194   1          /*
 195   1              刚上电直接获取一次，作为油量的状态
 196   1          */
 197   1          {
 198   2              static u8 status = STATUS_JUST_POWER_ON;
 199   2              if (STATUS_JUST_POWER_ON == status) // 如果是第一次上电
 200   2              {
 201   3                  if (fuel_capacity_scan_cnt >= FUEL_UPDATE_TIME_WHEN_POWER_ON)
 202   3                  {
 203   4                      fuel_capacity_scan_cnt = 0;
 204   4                      adc_sel_pin(ADC_PIN_FUEL); // 内部至少占用1ms
 205   4                      adc_val = adc_getval();    //
 206   4                      samples_init(adc_val); // 滑动平均滤波初始化
 207   4                      fuel_adc_val = adc_val;
 208   4      
 209   4                      fuel_percent = convert_fuel_adc_to_percent(fuel_adc_val);
 210   4      
 211   4                      fuel_gear = convert_fuel_percent_to_gear(fuel_percent);
 212   4      
 213   4                      // printf("power on, fuel_percent:%bu\n", fuel_percent);
 214   4                      fun_info.fuel = fuel_percent;
 215   4                      fuel_adc_val = 0;
 216   4                      flag_get_fuel = 1;
 217   4      
 218   4                      status = STATUS_IN_SERVICE;
 219   4                  }
 220   3              }
 221   2          }
 222   1      
C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     07/31/2025 17:40:06 PAGE 5   

 223   1          adc_sel_pin(ADC_PIN_FUEL); // 内部至少占用1ms
 224   1          adc_val = adc_getval();    //
 225   1          fuel_adc_val = get_filtered_adc(adc_val);
 226   1      
 227   1          if (fuel_capacity_scan_cnt >= FUEL_UPDATE_TIME)
 228   1          {
 229   2              u8 cur_fuel_gear = 0;
 230   2              // 如果到了扫描更新时间
 231   2              fuel_capacity_scan_cnt = 0;
 232   2      
 233   2              fuel_percent = convert_fuel_adc_to_percent(fuel_adc_val);
 234   2              cur_fuel_gear = convert_fuel_percent_to_gear(fuel_percent);
 235   2      
 236   2              if (cur_fuel_gear != fuel_gear)
 237   2              {
 238   3                  flag_timer_scan_update_fuel_gear = 1;
 239   3              }
 240   2              else
 241   2              {
 242   3                  // 如果当前油量挡位与上一次的油量挡位相同
 243   3                  flag_timer_scan_update_fuel_gear = 0;
 244   3      
 245   3                  fun_info.fuel = fuel_percent;
 246   3                  flag_get_fuel = 1; // 发送油量百分比数据
 247   3              }
 248   2      
 249   2              // 如果更新油量的时间到来，也发送一次油量百分比数据，更新 last_fuel_per
             -cent
 250   2              if (flag_update_fuel_gear)
 251   2              {
 252   3                  flag_update_fuel_gear = 0;
 253   3      
 254   3      #if 1
 255   3                  // 每次更新油量百分比，只变化一个挡位；
 256   3                  // 只有当前油量百分比与上一次记录的油量百分比不同，且更新油量挡
             -的时间到来，才会进入
 257   3                  if (cur_fuel_gear != fuel_gear)
 258   3                  {
 259   4                      u8 i;
 260   4      
 261   4                      if (fuel_gear > cur_fuel_gear)
 262   4                      {
 263   5                          if (fuel_gear > 0)
 264   5                          {
 265   6                              fuel_gear--;
 266   6                          }
 267   5                      }
 268   4                      else
 269   4                      {
 270   5                          if (fuel_gear < 6)
 271   5                          {
 272   6                              fuel_gear++;
 273   6                          }
 274   5                      }
 275   4      
 276   4                      for (i = 0; i < 255; i++)
 277   4                      {
 278   5                          u8 tmp = convert_fuel_percent_to_gear(i);
 279   5                          if (tmp == fuel_gear)
 280   5                          {
 281   6                              fuel_percent = i; // 得到变化一个挡位后对应的油量百分比
 282   6                              break;
C51 COMPILER V9.60.7.0   FUEL_CAPACITY                                                     07/31/2025 17:40:06 PAGE 6   

 283   6                          }
 284   5                      }
 285   4                  }
 286   3      #endif
 287   3      
 288   3                  fun_info.fuel = fuel_percent;
 289   3                  flag_get_fuel = 1; // 发送油量百分比数据
 290   3              }
 291   2      
 292   2              // printf("fuel_percent:%bu\n", fuel_percent);
 293   2              // fun_info.fuel = fuel_percent;
 294   2              // fuel_adc_val = 0;
 295   2              // flag_get_fuel = 1;
 296   2          } //  if (fuel_capacity_scan_cnt >= FUEL_UPDATE_TIME)
 297   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    977    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     49      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
