C51 COMPILER V9.60.7.0   IIC_ON_CHIP                                                       08/05/2025 17:55:48 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE IIC_ON_CHIP
OBJECT MODULE PLACED IN .\Release\Objects\iic_on_chip.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\iic_on_chip.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECT
                    -OR(0X000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT
                    -(.\Release\Listings\iic_on_chip.lst) OBJECT(.\Release\Objects\iic_on_chip.obj)

line level    source

   1          // èŠ¯ç‰‡ç‰‡ä¸Šå¤–è®¾iicé©±åŠ¨æºç¨‹åº
   2          
   3          #include "iic_on_chip.h"
   4          #include "my_config.h"
   5          
   6          /* The direction of the write E2prom. */
   7          #define WRITE_E2PROM_DIRECTION (0)
   8          /* The direction of the read E2prom. */
   9          #define READ_E2PROM_DIRECTION (1)
  10          
  11          /**
  12           * @brief  IIC sends 1 byte data function
  13           * @param  iic_data: IIC data
  14           * @param  flag: 0: None  1:send start   2:send stop
  15           * @retval Returns 1 and receives an ACK
  16           */
  17          u8 iic_master_tx(u8 iic_data, u8 flag)
  18          {
  19   1      #define START_FLAG (1)
  20   1      #define STOP_FLAG (2)
  21   1      
  22   1          u8 ack_flag = 0;
  23   1      
  24   1          if (flag == START_FLAG)
  25   1          {
  26   2              // é…ç½®å‘é€èµ·å§‹ä½
  27   2              I2C_CON |= (I2C_START_BIT(0x1) | I2C_SI_CLEAR(0x1));
  28   2              // ç­‰å¾… SI ç½® 1ï¼Œ èµ·å§‹ä½å‘é€æˆåŠŸæ—¶ä¼šç½® 1ï¼Œ å…¶å®ƒæƒ…å†µä¹Ÿå¯èƒ½ä¼šç½® 1ï¼Œ éœ€è¦æ
             -³¨æ„
  29   2              while (!(I2C_STA & I2C_SI_STA(0x1)))
  30   2                  ;
  31   2              I2C_CON &= ~I2C_START_BIT(0x1);
  32   2      
  33   2              // åˆ¤æ–­æ¨¡å—çŠ¶æ€
  34   2              if (!(((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x08) ||
  35   2                    ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x10)))
  36   2              {
  37   3                  return 0;
  38   3              }
  39   2          }
  40   1      
  41   1          // å†™å…¥ç›®æ ‡ä»æœºåœ°å€
  42   1          I2C_DATA = iic_data;
  43   1          // ç­‰å¾…åœ°å€å‘é€å®Œæˆ
  44   1          while (!(I2C_STA & I2C_SI_STA(0x1)))
  45   1              ;
  46   1      
  47   1          // åˆ¤æ–­æ˜¯å¦æ”¶åˆ° ACK
  48   1          if (((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x18) ||
  49   1              ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x28) ||
  50   1              ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x40))
  51   1          {
  52   2              ack_flag = 1;
C51 COMPILER V9.60.7.0   IIC_ON_CHIP                                                       08/05/2025 17:55:48 PAGE 2   

  53   2          }
  54   1          else
  55   1          {
  56   2              ack_flag = 0;
  57   2          }
  58   1      
  59   1          if (flag == STOP_FLAG)
  60   1          {
  61   2              // é…ç½®å‘é€åœæ­¢ä½
  62   2              I2C_CON |= (I2C_STOP_BIT(0x1) | I2C_SI_CLEAR(0x1));
  63   2          }
  64   1      
  65   1          return ack_flag;
  66   1      }
  67          
  68          /**
  69           * @brief  IIC receive 1 byte data function
  70           * @param  ack_en: 0:Send NACK  1:Send ACK   2:Send stop
  71           * @retval Returns data
  72           */
  73          u8 iic_master_rx(u8 flag)
  74          {
  75   1      #define NACK_FLAG (0)
  76   1      #define ACK_FLAG (1)
  77   1      #define STOP_FLAG (2)
  78   1      
  79   1          u8 ack_flag = 0;
  80   1          u8 iic_data = 0;
  81   1      
  82   1          if (flag == ACK_FLAG)
  83   1          {
  84   2              // æ¥æ”¶å®Œ1byteæ•°æ®å‘é€ACK
  85   2              I2C_CON |= I2C_ACK_NACK_BIT(0x1);
  86   2              if (I2C_STA & I2C_SI_STA(0x1))
  87   2              {
  88   3                  I2C_CON |= I2C_SI_CLEAR(0x1);
  89   3              }
  90   2          }
  91   1      
  92   1          // ç­‰å¾…æ¥æ”¶å®Œæˆ
  93   1          while (!(I2C_STA & I2C_SI_STA(0x1)))
  94   1              ;
  95   1      
  96   1          if (flag == NACK_FLAG)
  97   1          {
  98   2              // æ¥æ”¶å®Œ1byteæ•°æ®å‘é€NACK
  99   2              I2C_CON &= ~I2C_ACK_NACK_BIT(0x1);
 100   2          }
 101   1          if (flag == STOP_FLAG)
 102   1          {
 103   2              // é…ç½®å‘é€åœæ­¢ä½
 104   2              I2C_CON |= (I2C_STOP_BIT(0x1) | I2C_SI_CLEAR(0x1));
 105   2          }
 106   1      
 107   1          // å¼€å‘æ—¶æ­¤å¤„çš„å¤„ç†å¯æ³¨é‡Šæ‰
 108   1          if ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x50)
 109   1          {
 110   2              // æˆåŠŸå‘é€ ACK
 111   2              ack_flag = 1;
 112   2          }
 113   1          else if ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x58)
 114   1          {
C51 COMPILER V9.60.7.0   IIC_ON_CHIP                                                       08/05/2025 17:55:48 PAGE 3   

 115   2              // æˆåŠŸå‘é€ NACK
 116   2              ack_flag = 0;
 117   2          }
 118   1      
 119   1          return I2C_DATA;
 120   1      }
 121          
 122          #if 1
 123          /**
 124           * @brief  E2prom iic write data function
 125           * @param  device_addr : Iic target device address. ç›®æ ‡å™¨ä»¶åœ°å€
 126           * @param  addr        : the addr of IIC slave where you want to write. æƒ³è¦å†™å…¥çš„IICä»è®¾å¤‡çš„å­˜å
             -‚¨åœ°å€
 127           * @param  p_buf       : The data buf to be sent. å¾…å‘é€çš„æ•°æ®ç¼“å†²åŒº
 128           * @param  len         : The amount of data to sent. The unit is byte. å¾…å‘é€çš„æ•°æ®é•¿åº¦ï¼Œå•ä½ï¼
             -šå­—èŠ‚
 129           * @retval Success/failure reads data from the IIC. æ“ä½œç»“æœï¼š0--å¤±è´¥ï¼Œ1--æˆåŠŸ
 130           */
 131          u8 iic_eeprom_write(u16 device_addr, u16 addr, u8 *p_buf, u16 len)
 132          {
 133   1      #define NONE_FLAG (0)
 134   1      #define START_FLAG (1)
 135   1      #define STOP_FLAG (2)
 136   1      
 137   1          u16 i = 0;
 138   1      
 139   1          // å‘é€å¼€å§‹ä¿¡å·å’Œè®¾å¤‡åœ°å€
 140   1          if (!iic_master_tx(device_addr | WRITE_E2PROM_DIRECTION, START_FLAG))
 141   1          {
 142   2              // user_printf("IIC send device addr failed\n");
 143   2              return 0;
 144   2          }
 145   1          // å‘é€memoryåœ°å€
 146   1          if (!iic_master_tx(addr >> 8, NONE_FLAG))
 147   1          {
 148   2              // user_printf("IIC send high addr failed\n");
 149   2              return 0;
 150   2          }
 151   1          if (!iic_master_tx(addr & 0xFF, NONE_FLAG))
 152   1          {
 153   2              // user_printf("IIC send low addr failed\n");
 154   2              return 0;
 155   2          }
 156   1      
 157   1          // å‘é€æ•°æ®
 158   1          for (i = 0; i < (len - 1); i++)
 159   1          {
 160   2              if (!iic_master_tx(*p_buf++, NONE_FLAG))
 161   2              {
 162   3                  // user_printf("IIC send dada failed\n");
 163   3                  return 0;
 164   3              }
 165   2          }
 166   1          // å‘é€æœ€å1byteæ•°æ®å¹¶å‘é€åœæ­¢ä½
 167   1          if (!iic_master_tx(*p_buf, STOP_FLAG))
 168   1          {
 169   2              // user_printf("IIC send dada and failed\n");
 170   2              return 0;
 171   2          }
 172   1      
 173   1          return 1;
 174   1      }
C51 COMPILER V9.60.7.0   IIC_ON_CHIP                                                       08/05/2025 17:55:48 PAGE 4   

 175          
 176          /**
 177           * @brief  E2prom iic read data function
 178           * @param  device_addr : Iic target device address. ç›®æ ‡å™¨ä»¶åœ°å€
 179           * @param  addr        : the addr of IIC slave where you want to read. æƒ³è¦è¯»å–çš„IICä»è®¾å¤‡çš„å­˜å‚
             -¨åœ°å€
 180           * @param  p_buf       : The data buf to be received. å¾…æ¥æ”¶çš„æ•°æ®ç¼“å†²åŒº
 181           * @param  len         : The amount of data to received. The unit is byte. å¾…æ¥æ”¶çš„æ•°æ®é•¿åº¦ï¼Œå•ä
             -½ï¼šå­—èŠ‚
 182           * @retval Success/failure reads data from the IIC. æ“ä½œç»“æœï¼š0--å¤±è´¥ï¼Œ1--æˆåŠŸ
 183           */
 184          u8 iic_eeprom_read(u16 device_addr, u16 addr, u8 *p_buf, u16 len)
 185          {
 186   1      #define NACK_FLAG (0)
 187   1      #define ACK_FLAG (1)
 188   1      #define NONE_FLAG (0)
 189   1      #define START_FLAG (1)
 190   1      #define STOP_FLAG (2)
 191   1      
 192   1          u16 i = 0;
 193   1      
 194   1          // å‘é€å¼€å§‹ä¿¡å·å’Œè®¾å¤‡åœ°å€
 195   1          if (!iic_master_tx(device_addr | WRITE_E2PROM_DIRECTION, START_FLAG))
 196   1          {
 197   2              // user_printf("IIC send device addr failed\n");
 198   2              return 0;
 199   2          }
 200   1          // å‘é€memoryåœ°å€
 201   1          if (!iic_master_tx(addr >> 8, NONE_FLAG))
 202   1          {
 203   2              // user_printf("IIC send haig addr failed\n");
 204   2              return 0;
 205   2          }
 206   1          if (!iic_master_tx(addr & 0xFF, NONE_FLAG))
 207   1          {
 208   2              // user_printf("IIC send low addr failed\n");
 209   2              return 0;
 210   2          }
 211   1      
 212   1          // å‘é€å¼€å§‹ä¿¡å·å’Œè®¾å¤‡åœ°å€
 213   1          if (!iic_master_tx(device_addr | READ_E2PROM_DIRECTION, START_FLAG))
 214   1          {
 215   2              // user_printf("IIC send device addr failed\n");
 216   2              return 0;
 217   2          }
 218   1      
 219   1          // æ¥æ”¶æ•°æ®å¹¶å‘é€ACK
 220   1          for (i = 0; i < (len - 2); i++)
 221   1          {
 222   2              *p_buf++ = iic_master_rx(ACK_FLAG);
 223   2          }
 224   1          // æ¥æ”¶æ•°æ®å¹¶å‘é€NACK
 225   1          *p_buf++ = iic_master_rx(NONE_FLAG);
 226   1          // æ¥æ”¶æœ€å1byteæ•°æ®ï¼Œå¹¶å‘é€åœæ­¢ä½
 227   1          *p_buf = iic_master_rx(STOP_FLAG);
 228   1      
 229   1          return 1;
 230   1      }
 231          #endif
 232          
 233          /**
 234           * @brief 24cxx iic eeprom è¯»å†™å…¥æ•°æ®å‡½æ•°
C51 COMPILER V9.60.7.0   IIC_ON_CHIP                                                       08/05/2025 17:55:48 PAGE 5   

 235           *          å™¨ä»¶åœ°å€åœ¨å® IIC_ON_CHIP_DEVICE_ADDR ä¸­å®šä¹‰ï¼Œä¾‹å¦‚ IIC_ON_CHIP_DEVICE_ADDR == 0xA0ï
             -¼Œé«˜å››ä½å™¨ä»¶åœ°å€ä¸º0b-1010ï¼Œå™¨ä»¶å¼•è„šçš„A2~A0ä¸º0b-000ã€‚
 236           *
 237           * @param page_id é¡µé¢idï¼Œä¾‹å¦‚ï¼Œ0~127é¡µï¼Œpage_addr = 0~127
 238           * @param p_buf å¾…å‘é€çš„æ•°æ®ç¼“å†²åŒº
 239           * @param len å¾…å‘é€çš„æ•°æ®é•¿åº¦ï¼Œå•ä½ï¼šå­—èŠ‚
 240           */
 241          void eeprom_24cxx_write(u8 page_id, u8 *p_buf, u16 len)
 242          {
 243   1          u16 addr = EEPROM_PAGE_X_ADDR(page_id); // è®¡ç®—eepromåœ°å€ï¼Œå°†ä¼ å…¥çš„idè½¬æ¢æˆå¯¹åº”çš„åœ°å€
 244   1          while (0 == iic_eeprom_write(IIC_ON_CHIP_DEVICE_ADDR, addr, p_buf, len))
 245   1              ;
 246   1      }
 247          
 248          void eeprom_24cxx_read(u8 page_id, u8 *p_buf, u16 len)
 249          {
 250   1          u16 addr = EEPROM_PAGE_X_ADDR(page_id); // è®¡ç®—eepromåœ°å€ï¼Œå°†ä¼ å…¥çš„idè½¬æ¢æˆå¯¹åº”çš„åœ°å€
 251   1      
 252   1          while (0 == iic_eeprom_read(IIC_ON_CHIP_DEVICE_ADDR, addr, p_buf, len))
 253   1              ;
 254   1      }
 255          
 256          void iic_config(void)
 257          {
 258   1          // IIC_CLK -- P21ï¼ŒIIC_SDA -- P22
 259   1          P2_MD0 &= ~(GPIO_P21_MODE_SEL(0x03)); // æ¸…ç©ºå¯¹åº”çš„å¯„å­˜å™¨é…ç½®
 260   1          P2_MD0 |= (GPIO_P21_MODE_SEL(0x02));  // æ•°å­—å¤ç”¨æ¨¡å¼
 261   1          P2_PU |= (GPIO_P21_PULL_UP(0x01));    // ä¸Šæ‹‰
 262   1          P2_ODN |= (GPIO_P21_ODN_EN(0x01));    // å¼€æ¼ä½¿èƒ½
 263   1          P2_AF0 |= GPIO_P21_FUNC_SEL(0x01);    // 0x1--I2C_CLK åŠŸèƒ½é€‰æ‹©
 264   1      
 265   1          P2_MD0 &= ~(GPIO_P22_MODE_SEL(0x03)); // æ¸…ç©ºå¯¹åº”çš„å¯„å­˜å™¨é…ç½®
 266   1          P2_MD0 |= (GPIO_P22_MODE_SEL(0x02));  // æ•°å­—å¤ç”¨æ¨¡å¼
 267   1          P2_PU |= (GPIO_P22_PULL_UP(0x01));    // ä¸Šæ‹‰
 268   1          P2_ODN |= (GPIO_P22_ODN_EN(0x01));    // å¼€æ¼ä½¿èƒ½
 269   1          P2_AF0 |= GPIO_P22_FUNC_SEL(0x01);    // 0x1--I2C_SDA åŠŸèƒ½é€‰æ‹©
 270   1      
 271   1          I2C_CON = I2C_CR_SEL(0x02); // é…ç½®æ³¢ç‰¹ç‡ï¼Œå¯æ ¹æ®è¡¨æ ¼è‡ªè¡Œé€‰æ‹©
 272   1          I2C_CON |= I2C_EN(0x1);     // ä½¿èƒ½æ¨¡å—
 273   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    627    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      39
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
