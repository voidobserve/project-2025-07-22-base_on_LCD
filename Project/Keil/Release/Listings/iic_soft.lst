C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE IIC_SOFT
OBJECT MODULE PLACED IN .\Release\Objects\iic_soft.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\iic_soft.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(
                    -0X000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\
                    -Release\Listings\iic_soft.lst) OBJECT(.\Release\Objects\iic_soft.obj)

line level    source

   1          #include "iic_soft.h"
   2          
   3          volatile eeprom_menu_t eeprom_menu_prev;
   4          volatile eeprom_menu_t eeprom_menu_next;
   5          volatile eeprom_saveinfo_t eeprom_saveinfo;
   6          
   7          // æ›´æ–°eepromä¸­ç›®å½•ç›¸å…³çš„æ•°æ®ï¼Œéœ€è¦æå‰å†™å¥½ eeprom_menu_prev å’Œ eeprom_menu_next
   8          void eeprom_menu_write(void)
   9          {
  10   1          eeprom_24cxx_write(0, (u8 *)&eeprom_menu_prev, sizeof(eeprom_menu_t));
  11   1          WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
  12   1          eeprom_24cxx_write(1, (u8 *)&eeprom_menu_next, sizeof(eeprom_menu_t));
  13   1      }
  14          
  15          void eeprom_menu_read(void)
  16          {
  17   1          eeprom_24cxx_read(0, (u8 *)&eeprom_menu_prev, sizeof(eeprom_menu_t));
  18   1          WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
  19   1          eeprom_24cxx_read(1, (u8 *)&eeprom_menu_next, sizeof(eeprom_menu_t));
  20   1      }
  21          
  22          void eeprom_menu_init(void)
  23          {
  24   1          eeprom_menu_read();
  25   1      
  26   1          if (eeprom_menu_prev.is_data_valid != EEPROM_DATA_VALID_VAL && eeprom_menu_next.is_data_valid != EEPRO
             -M_DATA_VALID_VAL)
  27   1          {
  28   2              // å¦‚æœä¸¤ä¸ªé¡µ çš„ç›®å½•è¯»åˆ°çš„æ•°æ®éƒ½æ˜¯æ— æ•ˆçš„ï¼Œè¯´æ˜æ˜¯ç¬¬ä¸€æ¬¡ä½¿ç”¨eepromï¼Œè¿›è
             -¡Œåˆå§‹åŒ–
  29   2              eeprom_menu_prev.cur_write_page_id = 2; // 0ä¸ºç›®å½•prevï¼Œ1ä¸ºç›®å½•nextï¼ŒçœŸæ­£çš„æ•°æ®ä»2å¼
             -€å§‹
  30   2              eeprom_menu_prev.is_data_valid = EEPROM_DATA_VALID_VAL;
  31   2      
  32   2              eeprom_menu_next = eeprom_menu_prev;
  33   2              eeprom_menu_write();
  34   2      
  35   2              // printf("all menus are invalid\n");
  36   2          }
  37   1          else if ((eeprom_menu_prev.is_data_valid == EEPROM_DATA_VALID_VAL && eeprom_menu_next.is_data_valid !=
             - EEPROM_DATA_VALID_VAL) ||
  38   1                   (eeprom_menu_prev.is_data_valid != EEPROM_DATA_VALID_VAL && eeprom_menu_next.is_data_valid ==
             - EEPROM_DATA_VALID_VAL))
  39   1          {
  40   2              // å¦‚æœä¸¤ä¸ªé¡µçš„ç›®å½•è¯»åˆ°çš„æ•°æ®æœ‰ä¸€ä¸ªé¡µæ˜¯æœ‰æ•ˆçš„ï¼Œæœ‰ä¸€ä¸ªé¡µæ˜¯æ— æ•ˆçš„
  41   2              // ç”¨æœ‰æ•ˆçš„é‚£ä¸ªé¡µçš„æ•°æ®è¿›è¡Œåˆå§‹åŒ–
  42   2      
  43   2              if (eeprom_menu_prev.is_data_valid == EEPROM_DATA_VALID_VAL)
  44   2              {
  45   3                  eeprom_menu_next = eeprom_menu_prev;
  46   3                  eeprom_24cxx_write(1, (u8 *)&eeprom_menu_next, sizeof(eeprom_menu_t));
  47   3              }
  48   2              else if (eeprom_menu_next.is_data_valid == EEPROM_DATA_VALID_VAL)
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 2   

  49   2              {
  50   3                  eeprom_menu_prev = eeprom_menu_next;
  51   3                  eeprom_24cxx_write(0, (u8 *)&eeprom_menu_prev, sizeof(eeprom_menu_t));
  52   3              }
  53   2      
  54   2              // printf("one of menus is valid\n");
  55   2          }
  56   1          else
  57   1          {
  58   2              // å¦‚æœä¸¤ä¸ªé¡µçš„ç›®å½•ä¸­çš„æ•°æ®éƒ½æœ‰æ•ˆ
  59   2              // printf("menus are valid\n");
  60   2      
  61   2              /*
  62   2                  åˆ¤æ–­ç›®å½•ä¸­ cur_write_page_id å½“å‰è¦å†™å…¥é‡Œç¨‹æ•°æ®çš„é¡µé¢ç¼–å·æ˜¯å¦ä¸€è‡´ï¼Œ
  63   2                  å¦‚æœä¸ä¸€è‡´ï¼Œä»¥æœ€å¤§çš„idä½œä¸ºæœ€æ–°çš„é¡µé¢ç¼–å·ï¼Œå†å†™å›eeprom
  64   2              */
  65   2              if (eeprom_menu_prev.cur_write_page_id > eeprom_menu_next.cur_write_page_id)
  66   2              {
  67   3                  eeprom_menu_next.cur_write_page_id = eeprom_menu_prev.cur_write_page_id;
  68   3                  eeprom_menu_write();
  69   3              }
  70   2              else if (eeprom_menu_prev.cur_write_page_id < eeprom_menu_next.cur_write_page_id)
  71   2              {
  72   3                  eeprom_menu_prev.cur_write_page_id = eeprom_menu_next.cur_write_page_id;
  73   3                  eeprom_menu_write();
  74   3              }
  75   2              else // (eeprom_menu_prev.cur_write_page_id == eeprom_menu_next.cur_write_page_id)
  76   2              {
  77   3                  // æ•°æ®ä¸€è‡´
  78   3              }
  79   2          }
  80   1      }
  81          
  82          #if USE_MY_DEBUG
              volatile bit flag_is_printf_eeprom_data;
              
              volatile eeprom_menu_t eeprom_menu;
              
              void eeprom_printf_all(void)
              {
                  u16 i;
              
                  // eeprom_menu_t eeprom_menu = {0};
                  eeprom_menu.cur_write_page_id = 0;
                  eeprom_menu.is_data_valid = 0;
                  eeprom_24cxx_read(0, (u8 *)&eeprom_menu, sizeof(eeprom_menu_t));
                  printf("eeprom_menu_prev.cur_write_page_id = %bu\n", eeprom_menu.cur_write_page_id);
                  printf("eeprom_menu_prev.is_data_valid = 0x %x\n", (u16)eeprom_menu.is_data_valid);
              
                  eeprom_menu.cur_write_page_id = 0;
                  eeprom_menu.is_data_valid = 0;
                  eeprom_24cxx_read(1, (u8 *)&eeprom_menu, sizeof(eeprom_menu_t));
                  printf("eeprom_menu_next.cur_write_page_id = %bu\n", eeprom_menu.cur_write_page_id);
                  printf("eeprom_menu_next.is_data_valid = 0x %x\n", (u16)eeprom_menu.is_data_valid);
              
                  printf("====================================================\n");
              
                  // for (i = 2; i < 128; i++)
                  for (i = 2; i < EEPROM_PAGE_NUMS; i++)
                  // for (i = 2; i < 10; i++)
                  {
                      eeprom_24cxx_read(i, (u8 *)&eeprom_saveinfo, sizeof(eeprom_saveinfo_t));
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 3   

                      printf("cur_page_id %u\n", i);
                      printf("eeprom_saveinfo.erase_cnt = %lu\n", eeprom_saveinfo.erase_cnt);
                      printf("eeprom_saveinfo.toal_mileage = %lu\n", eeprom_saveinfo.total_mileage);
                      printf("eeprom_saveinfo.subtotal_mileage = %lu\n", eeprom_saveinfo.subtotal_mileage);
                      printf("eeprom_saveinfo.subtotal_mileage_2 = %lu\n", eeprom_saveinfo.subtotal_mileage_2);
                      printf("====================================================\n");
                      WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
                  }
              }
              
              #endif
 122          
 123          void eeprom_24cxx_clear(void)
 124          {
 125   1          u16 i;
 126   1          // const u8 clear_data = 0x00;
 127   1          const u8 clear_data = 0xFF;
 128   1          for (i = 0; i < ((u16)128 * 32); i++)
 129   1          {
 130   2              while (iic_eeprom_write(i, (u8 *)&clear_data, 1))
 131   2              {
 132   3                  WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
 133   3              }
 134   2          }
 135   1      }
 136          
 137          // å‘eepromå†™å…¥éœ€è¦ä¿å­˜çš„æ•°æ®
 138          volatile eeprom_saveinfo_t eeprom_saveinfo_prev; // å­˜æ”¾ä»eepromè¯»å‡ºçš„æ•°æ®ï¼Œprevï¼ŒåŒä¸€ç»„æ•°æ
             -®çš„å‰ä¸€é¡µæ•°æ®
 139          volatile eeprom_saveinfo_t eeprom_saveinfo_next; // å­˜æ”¾ä»eepromè¯»å‡ºçš„æ•°æ®ï¼Œnextï¼ŒåŒä¸€ç»„æ•°æ
             -®çš„åä¸€é¡µæ•°æ®
 140          /*
 141              å‡½æ•°å†…éƒ¨ä¼šæŠŠ fun_info.save_info çš„æ•°æ®å†™å…¥eeprom
 142          */
 143          void eeprom_data_save(void)
 144          {
 145   1          u8 cur_save_info_id_prev; // å½“å‰ä¿å­˜æ•°æ®çš„é¡µidï¼Œprevï¼ŒåŒä¸€ç»„æ•°æ®çš„å‰ä¸€é¡µï¼ˆä¸ºäº†è
             -Š‚çœç¨‹åºç©ºé—´ï¼Œä¸è¿›è¡Œåˆå§‹åŒ–ï¼Œç”±å‡½æ•°å†…éƒ¨èµ‹å€¼ï¼‰
 146   1          u8 cur_save_info_id_next; // å½“å‰ä¿å­˜æ•°æ®çš„é¡µidï¼Œnextï¼ŒåŒä¸€ç»„æ•°æ®çš„åä¸€é¡µ
 147   1      
 148   1          u8 cur_write_page_id = 0; // å­˜æ”¾å¾…å†™å…¥æ•°æ®çš„åœ°å€å¯¹åº”id
 149   1          u32 cur_erase_cnt;        // å­˜æ”¾è¯»å–åˆ°çš„æ“¦å†™æ¬¡æ•°
 150   1      
 151   1          /*
 152   1              å†™å…¥å‰ï¼Œè¯»å–ç›®å½•ï¼Œæ ¹æ®ç›®å½•æ‰¾åˆ°è¦å†™å…¥çš„åœ°å€
 153   1      
 154   1              å¦‚æœç›®å½•çš„æ•°æ®ä¸ä¸€è‡´ï¼Œä»¥æœ€åå†™å…¥çš„åœ°å€ä½œä¸ºæ–°å†™å…¥åœ°å€ï¼ˆç›®å½•ä¸­çš„ä¸¤ä¸
             -ªåœ°å€ï¼Œæœ€åå†™å…¥çš„åœ°å€åº”è¯¥å¤§äºå¦ä¸€ä¸ªåœ°å€ï¼‰
 155   1          */
 156   1      
 157   1          eeprom_menu_read();
 158   1      
 159   1          // if (eeprom_menu_prev.is_data_valid == EEPROM_DATA_VALID_VAL && eeprom_menu_next.is_data_valid == EE
             -PROM_DATA_VALID_VAL)
 160   1          if (eeprom_menu_prev.cur_write_page_id == eeprom_menu_next.cur_write_page_id)
 161   1          {
 162   2              cur_write_page_id = eeprom_menu_prev.cur_write_page_id;
 163   2          }
 164   1          else
 165   1          {
 166   2              // å¦‚æœç›®å½•ä¸­çš„æ•°æ®ä¸ä¸€è‡´ï¼Œåˆ¤æ–­å“ªä¸ªåœ°å€æ›´å¤§ï¼Œå“ªä¸ªå°±ä½œä¸ºå¾…å†™å…¥çš„åœ°å
             -€çš„id
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 4   

 167   2              if (eeprom_menu_prev.cur_write_page_id > eeprom_menu_next.cur_write_page_id)
 168   2              {
 169   3                  cur_write_page_id = eeprom_menu_prev.cur_write_page_id;
 170   3              }
 171   2              else
 172   2              {
 173   3                  cur_write_page_id = eeprom_menu_next.cur_write_page_id;
 174   3              }
 175   2          }
 176   1      
 177   1          /*
 178   1              page[0]å’Œpage[1]å·²ç»ä½œä¸ºç›®å½•ä½¿ç”¨ï¼ˆid==0å’Œid==1ï¼‰ï¼Œ
 179   1              å‰©ä¸‹çš„é¡µé¢ï¼Œæ¯ä¸¤ä¸ªé¡µé¢ä½œä¸ºä¸€ç»„æ•°æ®ï¼Œ
 180   1              é‚£ä¹ˆå¶æ•°é¡µé¢ä½œä¸ºåŒä¸€ç»„é¡µé¢çš„å‰ä¸€ä¸ªé¡µé¢ï¼Œå¥‡æ•°é¡µé¢ä½œä¸ºåŒä¸€ç»„é¡µé¢çš„å
             -ä¸€ä¸ªé¡µé¢
 181   1      
 182   1              ä¾‹å¦‚ id == 2 ä½œä¸ºç¬¬ 1 ç»„é¡µé¢çš„å‰ä¸€ä¸ªé¡µé¢ prevï¼Œ
 183   1                  id == 3 ä½œä¸ºç¬¬ 1 ç»„é¡µé¢çš„åä¸€ä¸ªé¡µé¢ next
 184   1          */
 185   1          if (cur_write_page_id % 2 == 0)
 186   1          {
 187   2              /*
 188   2                  å¦‚æœå¾—åˆ°çš„æ˜¯å¶æ•°é¡µé¢ï¼Œ
 189   2                  å¾—åˆ°çš„å¶æ•°ï¼Œä½œä¸ºåŒä¸€ç»„é¡µé¢çš„ç¬¬ä¸€ä¸ªé¡µé¢ prev
 190   2                  å¾—åˆ°çš„å¶æ•° + 1ï¼Œä½œä¸ºåŒä¸€ç»„é¡µé¢çš„ç¬¬äºŒä¸ªé¡µé¢ next
 191   2              */
 192   2              cur_save_info_id_prev = cur_write_page_id;
 193   2              cur_save_info_id_next = cur_write_page_id + 1;
 194   2          }
 195   1          else
 196   1          {
 197   2              /*
 198   2                  å¦‚æœå¾—åˆ°çš„æ˜¯å¥‡æ•°é¡µé¢ï¼Œ
 199   2      
 200   2                  å¾—åˆ°çš„å¥‡æ•° - 1ï¼Œä½œä¸ºåŒä¸€ç»„é¡µé¢çš„ç¬¬ä¸€ä¸ªé¡µé¢ prev
 201   2                  å¾—åˆ°çš„å¥‡æ•°ï¼Œä½œä¸ºåŒä¸€ç»„é¡µé¢çš„ç¬¬äºŒä¸ªé¡µé¢ next
 202   2              */
 203   2              cur_save_info_id_prev = cur_write_page_id - 1;
 204   2              cur_save_info_id_next = cur_write_page_id;
 205   2          }
 206   1      
 207   1          /*
 208   1              å¾—åˆ°åŒä¸€ç»„é¡µé¢çš„å‰ã€åä¸¤ä¸ªé¡µé¢çš„idåï¼Œè¯»å–è¿™ä¸¤ä¸ªé¡µé¢å¯¹åº”çš„æ•°æ®
 209   1      
 210   1              å°†ä¸¤ä¸ªé¡µé¢çš„æ•°æ®è¿›è¡Œæ¯”è¾ƒï¼Œ ç”¨æ€»é‡Œç¨‹è¾ƒå¤§çš„æ•°æ® è¦†ç›– æ€»é‡Œç¨‹è¾ƒå°çš„æ•°æ
             -®
 211   1      
 212   1              å¦‚æœè¶…è¿‡äº†é™åˆ¶çš„æ“¦å†™æ¬¡æ•°ï¼Œè¦æ¢ä¸‹ä¸€ç»„é¡µé¢ï¼Œå¹¶ä¸”æ›´æ–°åˆ°ç›®å½•ä¸­
 213   1              å¦‚æœå†™å®Œä¹‹åï¼Œè®°å½•çš„é¡µé¢idä¸ç›®å½•ä¸­çš„idä¸ä¸€è‡´ï¼Œè¦æ›´æ–°ç›®å½•ä¸­è®°å½•çš„é¡µé
             -¢id
 214   1          */
 215   1          eeprom_24cxx_read((cur_save_info_id_prev), (u8 *)&eeprom_saveinfo_prev, sizeof(eeprom_saveinfo_t));
 216   1          eeprom_24cxx_read((cur_save_info_id_next), (u8 *)&eeprom_saveinfo_next, sizeof(eeprom_saveinfo_t));
 217   1      
 218   1          // æ•°æ®æ— æ•ˆï¼Œå¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡è¯»å–ï¼Œæˆ–è€…ç”±äºå†™å…¥æ—¶æ‰ç”µå¯¼è‡´æ•°æ®ä¸¢å¤±
 219   1          if (eeprom_saveinfo_prev.is_data_valid != EEPROM_DATA_VALID_VAL)
 220   1          {
 221   2              eeprom_saveinfo_prev.erase_cnt = 0;
 222   2              eeprom_saveinfo_prev.total_mileage = 0;
 223   2              eeprom_saveinfo_prev.subtotal_mileage = 0;
 224   2              eeprom_saveinfo_prev.subtotal_mileage_2 = 0;
 225   2              eeprom_saveinfo_prev.is_data_valid = EEPROM_DATA_VALID_VAL;
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 5   

 226   2          }
 227   1      
 228   1          // æ•°æ®æ— æ•ˆï¼Œå¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡è¯»å–ï¼Œæˆ–è€…ç”±äºå†™å…¥æ—¶æ‰ç”µå¯¼è‡´æ•°æ®ä¸¢å¤±
 229   1          if (eeprom_saveinfo_next.is_data_valid != EEPROM_DATA_VALID_VAL)
 230   1          {
 231   2              eeprom_saveinfo_next = eeprom_saveinfo_prev;
 232   2          }
 233   1      
 234   1          if (eeprom_saveinfo_prev.total_mileage < eeprom_saveinfo_next.total_mileage)
 235   1          {
 236   2              /*
 237   2                  å¦‚æœå‰ä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹è¦å°äºåä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹ï¼Œ
 238   2                  åä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹ åŠ ä¸Š æ–°å¢çš„æ€»é‡Œç¨‹å¢é‡ï¼Œå¾—åˆ°çš„æ€»é‡Œç¨‹ä¿å­˜åˆ°å‰ä¸
             -€ä¸ªé¡µé¢ä¸­ï¼Œ
 239   2                  åä¸€ä¸ªé¡µé¢ä½œä¸ºå¤‡ä»½ï¼Œä¹Ÿä¿å­˜ä¸‹æ¥
 240   2              */
 241   2              eeprom_saveinfo_next.total_mileage = fun_info.save_info.total_mileage;
 242   2              eeprom_saveinfo_next.subtotal_mileage = fun_info.save_info.subtotal_mileage;
 243   2              eeprom_saveinfo_next.subtotal_mileage_2 = fun_info.save_info.subtotal_mileage_2;
 244   2      
 245   2              cur_erase_cnt = eeprom_saveinfo_next.erase_cnt; // å­˜æ”¾æ“¦å†™æ¬¡æ•°
 246   2              eeprom_saveinfo_prev = eeprom_saveinfo_next;
 247   2          }
 248   1          else
 249   1          {
 250   2              /*
 251   2                  å¦‚æœå‰ä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹è¦ å¤§äºæˆ–ç­‰äº åä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹ï¼Œ
 252   2                  å‰ä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹ åŠ ä¸Š æ–°å¢çš„æ€»é‡Œç¨‹å¢é‡ï¼Œå¾—åˆ°çš„æ€»é‡Œç¨‹ä¿å­˜åˆ°åä¸
             -€ä¸ªé¡µé¢ä¸­ï¼Œ
 253   2                  å‰ä¸€ä¸ªé¡µé¢ä½œä¸ºå¤‡ä»½ï¼Œä¹Ÿä¿å­˜ä¸‹æ¥
 254   2              */
 255   2      
 256   2              eeprom_saveinfo_prev.total_mileage = fun_info.save_info.total_mileage;
 257   2              eeprom_saveinfo_prev.subtotal_mileage = fun_info.save_info.subtotal_mileage;
 258   2              eeprom_saveinfo_prev.subtotal_mileage_2 = fun_info.save_info.subtotal_mileage_2;
 259   2      
 260   2              cur_erase_cnt = eeprom_saveinfo_prev.erase_cnt; // å­˜æ”¾æ“¦å†™æ¬¡æ•°
 261   2              eeprom_saveinfo_next = eeprom_saveinfo_prev;
 262   2          }
 263   1      
 264   1          cur_erase_cnt++; // æ“¦å†™æ¬¡æ•°ç´¯åŠ 
 265   1          eeprom_saveinfo_prev.erase_cnt = cur_erase_cnt;
 266   1          eeprom_saveinfo_next.erase_cnt = cur_erase_cnt;
 267   1          if (cur_erase_cnt > EEPROM_MAX_ERASE_COUNTS_PER_PAGE)
 268   1          {
 269   2              // å¦‚æœè¶…è¿‡äº†ä¸€ç»„é¡µé¢çš„æœ€å¤§æ“¦å†™æ¬¡æ•°ï¼Œæ›´æ¢ä¸‹ä¸€ç»„é¡µé¢
 270   2      
 271   2              cur_save_info_id_prev = cur_save_info_id_next + 1; // å½“å‰ä¸ºå¥‡æ•°idï¼ŒåŠ ä¸€ï¼Œä¸ºå¶æ•°idï¼Œæ
             -˜¯ä¸‹ä¸€ç»„é¡µé¢çš„ç¬¬ä¸€ä¸ªé¡µé¢
 272   2              cur_save_info_id_next = cur_save_info_id_prev + 1;
 273   2      
 274   2              if (cur_save_info_id_prev >= (EEPROM_PAGE_NUMS - 2))
 275   2              {
 276   3                  // é˜²æ­¢ç›®å½•å’Œæ“¦å†™çš„ä½ç½®è¶Šç•Œï¼Œè¶…å‡ºäº†eepromèƒ½å­˜æ”¾çš„ä½ç½®
 277   3                  cur_save_info_id_prev = EEPROM_PAGE_NUMS - 2; // eepromçš„å€’æ•°ç¬¬2é¡µ
 278   3                  cur_save_info_id_next = EEPROM_PAGE_NUMS - 1; // eepromçš„å€’æ•°ç¬¬1é¡µï¼Œæœ€åä¸€é¡µ
 279   3              }
 280   2      
 281   2              // æ“¦å†™æ¬¡æ•°æ¸…é›¶
 282   2              eeprom_saveinfo_prev.erase_cnt = 0;
 283   2              eeprom_saveinfo_next.erase_cnt = 0;
 284   2          }
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 6   

 285   1      
 286   1          eeprom_24cxx_write(cur_save_info_id_prev, (u8 *)&eeprom_saveinfo_prev, sizeof(eeprom_saveinfo_t));
 287   1          eeprom_24cxx_write(cur_save_info_id_next, (u8 *)&eeprom_saveinfo_next, sizeof(eeprom_saveinfo_t));
 288   1      
 289   1          /*
 290   1              å¦‚æœå†™å…¥çš„é¡µé¢idä¸ç›®å½•è®°å½•çš„idä¸ä¸€æ ·ï¼Œåˆ™æ›´æ–°ç›®å½•è®°å½•çš„id
 291   1          */
 292   1          if (cur_save_info_id_prev != eeprom_menu_prev.cur_write_page_id)
 293   1          {
 294   2              eeprom_menu_prev.cur_write_page_id = cur_save_info_id_prev;
 295   2              eeprom_menu_prev.is_data_valid = EEPROM_DATA_VALID_VAL;
 296   2      
 297   2              // eeprom_menu_next.cur_write_page_id = cur_save_info_id_prev;
 298   2              // eeprom_menu_next.is_data_valid = EEPROM_DATA_VALID_VAL;
 299   2      
 300   2              eeprom_menu_next = eeprom_menu_prev;
 301   2      
 302   2              eeprom_menu_write();
 303   2          }
 304   1      }
 305          
 306          // static void delay_5us(u32 us)
 307          // {
 308          //     u32 b = us * 1;
 309          //     // u32 b = us * 2;
 310          //     while (b--)
 311          //     {
 312          //     }
 313          // }
 314          
 315          /**
 316           * @brief  iic start function
 317           * @param  None
 318           * @retval None
 319           */
 320          void iic_start(void)
 321          {
 322   1          // èµ·å§‹æ—¶ï¼Œç³»ç»Ÿæ—¶é’Ÿçº¿ï¼ˆSCLKï¼‰å’Œç³»ç»Ÿæ•°æ®çº¿ï¼ˆSDATAï¼‰éƒ½å¤„äºé«˜ç”µå¹³
 323   1          SDA_OUT(); // SDAçº¿è¾“å‡º
 324   1          IIC_SDA = 1;
 325   1          IIC_SCL = 1;
 326   1          // å»¶æ—¶å‡½æ•°æ˜¯ä¸ºäº†ç­‰å¾…é…ç½®å®Œæˆï¼Œå½“SCLKä¸ºé«˜ç”µå¹³æ—¶ï¼ŒSDATAè·³å˜ä¸ºä½ç”µå¹³
 327   1          // ç´§æ¥ç€SCLKä¹Ÿè·³å˜ä¸ºä½ç”µå¹³
 328   1          // äº§ç”Ÿä¸€ä¸ªèµ·å§‹ä¿¡å·
 329   1          IIC_DELAY();
 330   1          IIC_SDA = 0; // START:when CLK is high,DATA change form high to low
 331   1          IIC_DELAY();
 332   1          IIC_SCL = 0;
 333   1      }
 334          
 335          /**
 336           * @brief  iic stop function
 337           * @param  None
 338           * @retval None
 339           */
 340          void iic_stop(void)
 341          {
 342   1          SDA_OUT(); // SDAçº¿è¾“å‡º
 343   1      
 344   1          // é…ç½®æ—¶é’Ÿçº¿å’Œæ•°æ®çº¿å‡ä¸ºä½ç”µå¹³
 345   1          IIC_SCL = 0;
 346   1          IIC_SDA = 0; // STOP:when CLK is high DATA change form low to high
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 7   

 347   1          IIC_DELAY();
 348   1      
 349   1          // é…ç½®æ—¶é’Ÿçº¿ä¸ºé«˜ç”µå¹³
 350   1          IIC_SCL = 1;
 351   1          IIC_DELAY();
 352   1      
 353   1          // åœ¨æ—¶é’Ÿçº¿ä¸ºé«˜ç”µå¹³æ—¶ï¼Œè¾“å‡ºçš„æ•°æ®çº¿ä»ä½ç”µå¹³è·³å˜åˆ°é«˜ç”µå¹³ï¼Œåˆ™äº§ç”Ÿäº†åœæ­¢
             -ä¿¡å·
 354   1          IIC_SDA = 1;
 355   1          IIC_DELAY();
 356   1      }
 357          
 358          /**
 359           * @brief  wait ack function
 360           * @param  None
 361           * @retval 1:no ack 0:ack
 362           */
 363          u8 iic_wait_ack(void)
 364          {
 365   1          u8 timeout = 0;
 366   1      
 367   1          SDA_IN(); // SDAè®¾ç½®ä¸ºè¾“å…¥
 368   1      
 369   1          // é…ç½®ä¸ºé«˜ç”µå¹³
 370   1          IIC_SDA = 1;
 371   1          IIC_DELAY();
 372   1      
 373   1          // é…ç½®ä¸ºé«˜ç”µå¹³
 374   1          IIC_SCL = 1;
 375   1          IIC_DELAY();
 376   1      
 377   1          while (IIC_SDA)
 378   1          {
 379   2              // ç­‰å¾…SDAæ‹‰ä½ï¼Œè¡¨ç¤ºåº”ç­”å¸¦æ¥ï¼Œä¸ç„¶ä¸€ç›´whileå¾ªç¯ï¼Œç›´åˆ°è¶…æ—¶
 380   2              timeout++;
 381   2              if (timeout > 250)
 382   2              {
 383   3                  iic_stop(); // ç­‰å¾…è¶…æ—¶ï¼Œåº”ç­”å¤±è´¥ï¼Œå‘å‡ºåœæ­¢ä¿¡å·
 384   3                  return 1;   // è¿”å›1ï¼Œè¡¨ç¤ºå¤±è´¥
 385   3              }
 386   2              IIC_DELAY();
 387   2          }
 388   1          IIC_SCL = 0; // SCLæ‹‰ä½
 389   1      
 390   1          return 0; // è¿”å›0ï¼Œè¡¨ç¤ºæˆåŠŸ
 391   1      }
 392          
 393          /**
 394           * @brief  iic ack function
 395           * @param  None
 396           * @retval None
 397           */
 398          void iic_ack(void)
 399          {
 400   1          IIC_SCL = 0;
 401   1          SDA_OUT();
 402   1          IIC_SDA = 0;
 403   1          IIC_DELAY();
 404   1          IIC_SCL = 1;
 405   1          IIC_DELAY();
 406   1          IIC_SCL = 0;
 407   1      }
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 8   

 408          
 409          /**
 410           * @brief  iic no ack function
 411           * @param  None
 412           * @retval None
 413           */
 414          void iic_nack(void)
 415          {
 416   1          IIC_SCL = 0;
 417   1          SDA_OUT();
 418   1          IIC_SDA = 1;
 419   1          IIC_DELAY();
 420   1          IIC_SCL = 1;
 421   1          IIC_DELAY();
 422   1          IIC_SCL = 0;
 423   1      }
 424          
 425          /**
 426           * @brief  iic send 1 byte data function
 427           * @param  None
 428           * @retval 1:Ack 0:No Ack
 429           */
 430          void iic_send_byte(u8 txd)
 431          {
 432   1          u8 i;
 433   1      
 434   1          // é…ç½®P03ä¸ºè¾“å‡ºæ¨¡å¼
 435   1          SDA_OUT(); // SDAçº¿è¾“å‡ºæ¨¡å¼
 436   1      
 437   1          // åªæœ‰åœ¨æ—¶é’Ÿçº¿ä¸º0çš„æƒ…å†µä¸‹ï¼Œæ•°æ®çº¿æ‰å¯ä»¥è¿›è¡Œé«˜ä½ç”µå¹³çš„è·³å˜
 438   1          IIC_SCL = 0; // æ‹‰ä½æ—¶é’Ÿå¼€å§‹æ•°æ®ä¼ è¾“
 439   1      
 440   1          for (i = 0; i < 8; i++)
 441   1          {                                // forå¾ªç¯ï¼Œä¸€ä½ä¸€ä½çš„å‘é€ï¼Œä»æœ€é«˜ä½ ä½7å¼€å§‹
 442   2              IIC_SDA = (txd & 0x80) >> 7; // é™¤äº†ä½7å¤–ï¼Œå…¶ä½™å…¨å±è”½ä¸º0ï¼Œç„¶åå³ç§»åˆ°ä½0ï¼Œç»™SDA
             -æ•°æ®çº¿
 443   2              txd <<= 1;                   // å·¦ç§»ä¸€ä½ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡å‘é€
 444   2              IIC_DELAY();
 445   2      
 446   2              // å‘é€å®Œæˆä¹‹åï¼Œæ—¶é’Ÿçº¿æ‹‰é«˜
 447   2              IIC_SCL = 1;
 448   2              IIC_DELAY();
 449   2      
 450   2              // ç´§æ¥ç€æ‹‰ä½
 451   2              IIC_SCL = 0;
 452   2              IIC_DELAY();
 453   2      
 454   2              // å‘é€å®Œä¸€ä¸ªæ•°æ®éƒ½å°†æ—¶é’Ÿçº¿è¿›è¡Œä¸€æ¬¡çš„æ‹‰é«˜å’Œæ‹‰ä½ï¼Œå®Œæˆä¸€ä¸ªä½çš„ä¼ è¾“
 455   2          }
 456   1      }
 457          
 458          /**
 459           * @brief  iic read 1 byte function
 460           * @param  none
 461           * @retval ack=1,send ack=0;ack=0,send no ack
 462           */
 463          u8 iic_read_byte(unsigned char ack)
 464          {
 465   1          // unsigned char i, receive = 0;
 466   1          u8 i;
 467   1          u8 receive = 0;
 468   1      
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 9   

 469   1          SDA_IN(); // SDAè®¾ç½®ä¸ºè¾“å…¥
 470   1      
 471   1          for (i = 0; i < 8; i++)
 472   1          { // forå¾ªç¯ï¼Œä¸€ä½ä¸€ä½çš„è¯»å–ï¼Œä»æœ€é«˜ä½ ä½7å¼€å§‹
 473   2              IIC_SCL = 0;
 474   2              IIC_DELAY();
 475   2              IIC_SCL = 1;
 476   2              receive <<= 1; // å·¦ç§»ä¸€ä½ï¼Œå‡†å¤‡ä¸‹æ¬¡çš„è¯»å–
 477   2      
 478   2              if (IIC_SDA)
 479   2              {
 480   3                  receive++;
 481   3              }
 482   2              IIC_DELAY();
 483   2          }
 484   1      
 485   1          if (!ack)
 486   1          {               // ä¸éœ€è¦å‘é€
 487   2              iic_nack(); // å‘é€nACK
 488   2          }
 489   1          else
 490   1          {              // éœ€è¦å‘é€
 491   2              iic_ack(); // å‘é€ACK
 492   2          }
 493   1      
 494   1          return receive;
 495   1      }
 496          
 497          /**
 498           * @brief  åœ¨AT24CXXé‡Œé¢çš„æŒ‡å®šåœ°å€å¼€å§‹è¯»å‡ºæŒ‡å®šä¸ªæ•°çš„æ•°æ®
 499           * @param  addr : å¼€å§‹è¯»å‡ºçš„åœ°å€ å¯¹24c512ä¸º0~65535
 500           * @param  pBuffer  : æ•°æ®æ•°ç»„é¦–åœ°å€
 501           * @param  num_read_data: è¦è¯»å‡ºæ•°æ®çš„ä¸ªæ•°
 502           * @retval u8  0--æˆåŠŸï¼Œ1--å¤±è´¥
 503           */
 504          u8 iic_eeprom_read(u16 addr, u8 *pBuffer, u16 num_read_data)
 505          {
 506   1          // èµ·å§‹ä¿¡å·
 507   1          iic_start();
 508   1      
 509   1          // å‘é€è®¾å¤‡åœ°å€
 510   1          // iic_send_byte(E2PROM_DEVICE_ADDR + ((device_addr / 256) << 1));
 511   1          iic_send_byte(E2PROM_DEVICE_ADDR | IIC_WRITE_CMD);
 512   1      
 513   1          // ç­‰å¾…åº”ç­”
 514   1          if (iic_wait_ack())
 515   1          {
 516   2              return 1;
 517   2          }
 518   1      
 519   1          // iic_send_byte(addr / 256 >> 8); // å‘é€é«˜åœ°å€
 520   1          iic_send_byte(addr >> 8); // å‘é€é«˜åœ°å€
 521   1      
 522   1          // ç­‰å¾…åº”ç­”
 523   1          if (iic_wait_ack())
 524   1          {
 525   2              return 1;
 526   2          }
 527   1      
 528   1          // iic_send_byte(addr % 256); // å‘é€ä½åœ°å€
 529   1          iic_send_byte(addr & 0xFF); // å‘é€ä½åœ°å€
 530   1      
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 10  

 531   1          // ç­‰å¾…åº”ç­”
 532   1          if (iic_wait_ack())
 533   1          {
 534   2              return 1;
 535   2          }
 536   1      
 537   1          IIC_DELAY();
 538   1      
 539   1          // èµ·å§‹ä¿¡å·
 540   1          iic_start();
 541   1          iic_send_byte(E2PROM_DEVICE_ADDR | IIC_READ_CMD); // è¿›å…¥æ¥æ”¶æ¨¡å¼
 542   1      
 543   1          // ç­‰å¾…åº”ç­”
 544   1          if (iic_wait_ack())
 545   1          {
 546   2              return 1;
 547   2          }
 548   1      
 549   1          num_read_data--;
 550   1          while (num_read_data)
 551   1          {
 552   2              *pBuffer++ = iic_read_byte(1);
 553   2              num_read_data--;
 554   2          }
 555   1          *pBuffer = iic_read_byte(0);
 556   1          // åœæ­¢ä¿¡å·
 557   1          iic_stop(); // äº§ç”Ÿä¸€ä¸ªåœæ­¢æ¡ä»¶
 558   1      
 559   1          return 0;
 560   1      }
 561          
 562          /**
 563           * @brief  åœ¨AT24CXXé‡Œé¢çš„æŒ‡å®šåœ°å€å¼€å§‹å†™å…¥æŒ‡å®šä¸ªæ•°çš„æ•°æ®
 564           * @param  addr : å¼€å§‹å†™å…¥çš„åœ°å€ å¯¹24c512ä¸º0~65535
 565           * @param  pBuffer   : æ•°æ®æ•°ç»„é¦–åœ°å€
 566           * @param  num_write_data: è¦å†™å…¥æ•°æ®çš„ä¸ªæ•°
 567           * @retval 0--æ“ä½œæˆåŠŸï¼Œ1--æ“ä½œå¤±è´¥
 568           */
 569          u8 iic_eeprom_write(u16 addr, u8 *pBuffer, u16 num_write_data)
 570          {
 571   1          // æ€»çº¿å‘é€ä¸€ä¸ªå¼€å§‹ä¿¡å·
 572   1          iic_start();
 573   1      
 574   1          // å‘é€è®¾å¤‡åœ°å€
 575   1          // iic_send_byte(E2PROM_DEVICE_ADDR + ((device_addr / 256) << 1));
 576   1          iic_send_byte(E2PROM_DEVICE_ADDR | IIC_WRITE_CMD);
 577   1      
 578   1          // åº”ç­”ä¿¡å·ï¼Œç­‰å¾…ä»æœºåº”ç­”
 579   1          if (iic_wait_ack())
 580   1          {
 581   2              return 1; // è¡¨ç¤ºæ“ä½œå¤±è´¥ï¼Œæ²¡æœ‰æ”¶åˆ°åº”ç­”
 582   2          }
 583   1      
 584   1          // iic_send_byte(addr / 256 >> 8); // å‘é€é«˜åœ°å€
 585   1          iic_send_byte(addr >> 8); // å‘é€é«˜åœ°å€
 586   1      
 587   1          // åº”ç­”ä¿¡å·ï¼Œç­‰å¾…ä»æœºåº”ç­”
 588   1          if (iic_wait_ack())
 589   1          {
 590   2              return 1; // è¡¨ç¤ºæ“ä½œå¤±è´¥ï¼Œæ²¡æœ‰æ”¶åˆ°åº”ç­”
 591   2          }
 592   1      
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 11  

 593   1          // iic_send_byte(addr % 256); // å‘é€ä½åœ°å€
 594   1          iic_send_byte(addr & 0xFF); // å‘é€ä½åœ°å€
 595   1      
 596   1          // åº”ç­”ä¿¡å·ï¼Œç­‰å¾…ä»æœºåº”ç­”
 597   1          if (iic_wait_ack())
 598   1          {
 599   2              return 1; // è¡¨ç¤ºæ“ä½œå¤±è´¥ï¼Œæ²¡æœ‰æ”¶åˆ°åº”ç­”
 600   2          }
 601   1      
 602   1          while (num_write_data--)
 603   1          {
 604   2              iic_send_byte(*pBuffer); // å‘é€å­—èŠ‚
 605   2              if (iic_wait_ack())
 606   2              {
 607   3                  return 1; // è¡¨ç¤ºæ“ä½œå¤±è´¥ï¼Œæ²¡æœ‰æ”¶åˆ°åº”ç­”
 608   3              }
 609   2      
 610   2              addr++;
 611   2              pBuffer++;
 612   2          }
 613   1      
 614   1          IIC_DELAY();
 615   1          // æ€»çº¿å‘é€ä¸€ä¸ªåœæ­¢ä¿¡å·
 616   1          iic_stop(); // äº§ç”Ÿä¸€ä¸ªåœæ­¢æ¡ä»¶
 617   1      
 618   1          return 0; // è¡¨ç¤ºæ“ä½œæˆåŠŸ
 619   1      }
 620          
 621          void eeprom_24cxx_write(u8 page_id, u8 *p_buf, u16 len)
 622          {
 623   1          u16 addr = EEPROM_PAGE_X_ADDR(page_id);
 624   1      
 625   1          while (iic_eeprom_write(addr, p_buf, len))
 626   1          {
 627   2              // printf("time out\n");
 628   2              WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
 629   2          };
 630   1      }
 631          
 632          void eeprom_24cxx_read(u8 page_id, u8 *p_buf, u16 len)
 633          {
 634   1          u16 addr = EEPROM_PAGE_X_ADDR(page_id);
 635   1          while (iic_eeprom_read(addr, p_buf, len))
 636   1          {
 637   2              WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
 638   2          };
 639   1      }
 640          
 641          void iic_config(void)
 642          {
 643   1          // åˆå§‹åŒ–IIC
 644   1          IIC_SDA = 1; // è®¾ç½®ä¸ºé«˜ç”µå¹³
 645   1          IIC_SCL = 1; // è®¾ç½®ä¸ºé«˜ç”µå¹³
 646   1      
 647   1          // P31 èŠ¯ç‰‡22è„šï¼Œç”¨ä½œSCL
 648   1          // P26 èŠ¯ç‰‡25è„šï¼Œç”¨ä½œSDA
 649   1          P3_MD0 &= ~GPIO_P31_MODE_SEL(0x03);
 650   1          P3_MD0 |= GPIO_P31_MODE_SEL(0x01);
 651   1          FOUT_S31 = GPIO_FOUT_AF_FUNC; // é€‰æ‹©AFåŠŸèƒ½è¾“å‡º
 652   1      
 653   1          P2_MD1 &= ~GPIO_P26_MODE_SEL(0x03);
 654   1          P2_MD1 |= GPIO_P26_MODE_SEL(0x1);
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/15/2025 17:30:45 PAGE 12  

 655   1          FOUT_S26 = GPIO_FOUT_AF_FUNC; // é€‰æ‹©AFåŠŸèƒ½è¾“å‡º
 656   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1554    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     55      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
