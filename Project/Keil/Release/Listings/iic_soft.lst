C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE IIC_SOFT
OBJECT MODULE PLACED IN .\Release\Objects\iic_soft.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\iic_soft.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(
                    -0X000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\
                    -Release\Listings\iic_soft.lst) OBJECT(.\Release\Objects\iic_soft.obj)

line level    source

   1          #include "iic_soft.h"
   2          
   3          volatile eeprom_menu_t eeprom_menu_prev;
   4          volatile eeprom_menu_t eeprom_menu_next;
   5          volatile eeprom_saveinfo_t eeprom_saveinfo;
   6          
   7          // æ›´æ–°eepromä¸­ç›®å½•ç›¸å…³çš„æ•°æ®ï¼Œéœ€è¦æå‰å†™å¥½ eeprom_menu_prev å’Œ eeprom_menu_next
   8          void eeprom_menu_write(void)
   9          {
  10   1          eeprom_24cxx_write(0, (u8 *)&eeprom_menu_prev, sizeof(eeprom_menu_t));
  11   1          eeprom_24cxx_write(1, (u8 *)&eeprom_menu_next, sizeof(eeprom_menu_t));
  12   1      }
  13          
  14          void eeprom_menu_read(void)
  15          {
  16   1          eeprom_24cxx_read(0, (u8 *)&eeprom_menu_prev, sizeof(eeprom_menu_t));
  17   1          eeprom_24cxx_read(1, (u8 *)&eeprom_menu_next, sizeof(eeprom_menu_t));
  18   1      }
  19          
  20          void eeprom_menu_init(void)
  21          {
  22   1          eeprom_menu_read();
  23   1      
  24   1          if (eeprom_menu_prev.is_data_valid != EEPROM_DATA_VALID_VAL && eeprom_menu_next.is_data_valid != EEPRO
             -M_DATA_VALID_VAL)
  25   1          {
  26   2              // å¦‚æœä¸¤ä¸ªé¡µ çš„ç›®å½•è¯»åˆ°çš„æ•°æ®éƒ½æ˜¯æ— æ•ˆçš„ï¼Œè¯´æ˜æ˜¯ç¬¬ä¸€æ¬¡ä½¿ç”¨eepromï¼Œè¿›è
             -¡Œåˆå§‹åŒ–
  27   2              eeprom_menu_prev.cur_write_page_id = 2; // 0ä¸ºç›®å½•prevï¼Œ1ä¸ºç›®å½•nextï¼ŒçœŸæ­£çš„æ•°æ®ä»2å¼
             -€å§‹
  28   2              eeprom_menu_prev.is_data_valid = EEPROM_DATA_VALID_VAL;
  29   2      
  30   2              eeprom_menu_next = eeprom_menu_prev;
  31   2              eeprom_menu_write();
  32   2      
  33   2              printf("all menus are invalid\n");
  34   2          }
  35   1          else if ((eeprom_menu_prev.is_data_valid == EEPROM_DATA_VALID_VAL && eeprom_menu_next.is_data_valid !=
             - EEPROM_DATA_VALID_VAL) ||
  36   1                   (eeprom_menu_prev.is_data_valid != EEPROM_DATA_VALID_VAL && eeprom_menu_next.is_data_valid ==
             - EEPROM_DATA_VALID_VAL))
  37   1          {
  38   2              // å¦‚æœä¸¤ä¸ªé¡µçš„ç›®å½•è¯»åˆ°çš„æ•°æ®æœ‰ä¸€ä¸ªé¡µæ˜¯æœ‰æ•ˆçš„ï¼Œæœ‰ä¸€ä¸ªé¡µæ˜¯æ— æ•ˆçš„
  39   2              // ç”¨æœ‰æ•ˆçš„é‚£ä¸ªé¡µçš„æ•°æ®è¿›è¡Œåˆå§‹åŒ–
  40   2      
  41   2              if (eeprom_menu_prev.is_data_valid == EEPROM_DATA_VALID_VAL)
  42   2              {
  43   3                  eeprom_menu_next = eeprom_menu_prev;
  44   3                  eeprom_24cxx_write(1, (u8 *)&eeprom_menu_next, sizeof(eeprom_menu_t));
  45   3              }
  46   2              else if (eeprom_menu_next.is_data_valid == EEPROM_DATA_VALID_VAL)
  47   2              {
  48   3                  eeprom_menu_prev = eeprom_menu_next;
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 2   

  49   3                  eeprom_24cxx_write(0, (u8 *)&eeprom_menu_prev, sizeof(eeprom_menu_t));
  50   3              }
  51   2      
  52   2              printf("one of menus is valid\n");
  53   2          }
  54   1          else
  55   1          {
  56   2              // å¦‚æœä¸¤ä¸ªé¡µçš„ç›®å½•ä¸­çš„æ•°æ®éƒ½æœ‰æ•ˆ
  57   2              printf("menus are valid\n");
  58   2          }
  59   1      }
  60          
  61          #if USE_MY_DEBUG
  62          volatile bit flag_is_printf_eeprom_data;
  63          
  64          volatile eeprom_menu_t eeprom_menu;
  65          
  66          void eeprom_printf_all(void)
  67          {
  68   1          u16 i;
  69   1      
  70   1          // eeprom_menu_t eeprom_menu = {0};
  71   1          eeprom_menu.cur_write_page_id = 0;
  72   1          eeprom_menu.is_data_valid = 0;
  73   1          eeprom_24cxx_read(0, (u8 *)&eeprom_menu, sizeof(eeprom_menu_t));
  74   1          printf("eeprom_menu_prev.cur_write_page_id = %bu\n", eeprom_menu.cur_write_page_id);
  75   1          printf("eeprom_menu_prev.is_data_valid = 0x %x\n", (u16)eeprom_menu.is_data_valid);
  76   1      
  77   1          eeprom_menu.cur_write_page_id = 0;
  78   1          eeprom_menu.is_data_valid = 0;
  79   1          eeprom_24cxx_read(1, (u8 *)&eeprom_menu, sizeof(eeprom_menu_t));
  80   1          printf("eeprom_menu_next.cur_write_page_id = %bu\n", eeprom_menu.cur_write_page_id);
  81   1          printf("eeprom_menu_next.is_data_valid = 0x %x\n", (u16)eeprom_menu.is_data_valid);
  82   1      
  83   1          printf("====================================================\n");
  84   1      
  85   1          // for (i = 2; i < 128; i++)
  86   1          // for (i = 2; i < 128; i++)
  87   1          for (i = 2; i < 10; i++)
  88   1          {
  89   2              eeprom_24cxx_read(i, (u8 *)&eeprom_saveinfo, sizeof(eeprom_saveinfo_t));
  90   2              printf("cur_page_id %u\n", i);
  91   2              printf("eeprom_saveinfo.erase_cnt = %lu\n", eeprom_saveinfo.erase_cnt);
  92   2              printf("eeprom_saveinfo.toal_mileage = %lu\n", eeprom_saveinfo.total_mileage);
  93   2              printf("eeprom_saveinfo.subtotal_mileage = %lu\n", eeprom_saveinfo.subtotal_mileage);
  94   2              printf("eeprom_saveinfo.subtotal_mileage_2 = %lu\n", eeprom_saveinfo.subtotal_mileage_2);
  95   2              printf("====================================================\n");
  96   2          }
  97   1      }
  98          
  99          void eeprom_24cxx_clear(void)
 100          {
 101   1          u16 i;
 102   1          const u8 clear_data = 0x00;
 103   1          for (i = 0; i < ((u16)128 * 32); i++)
 104   1          {
 105   2              while (iic_eeprom_write(i, (u8 *)&clear_data, 1))
 106   2                  ;
 107   2          }
 108   1      }
 109          
 110          #endif
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 3   

 111          
 112          // å‘eepromå†™å…¥éœ€è¦ä¿å­˜çš„æ•°æ®
 113          volatile eeprom_saveinfo_t eeprom_saveinfo_prev; // å­˜æ”¾ä»eepromè¯»å‡ºçš„æ•°æ®ï¼Œprevï¼ŒåŒä¸€ç»„æ•°æ
             -®çš„å‰ä¸€é¡µæ•°æ®
 114          volatile eeprom_saveinfo_t eeprom_saveinfo_next; // å­˜æ”¾ä»eepromè¯»å‡ºçš„æ•°æ®ï¼Œnextï¼ŒåŒä¸€ç»„æ•°æ
             -®çš„åä¸€é¡µæ•°æ®
 115          /*
 116              å‡½æ•°å†…éƒ¨ä¼šæŠŠ fun_info.save_info çš„æ•°æ®å†™å…¥eeprom
 117          */
 118          void eeprom_data_save(void)
 119          {
 120   1          u8 cur_save_info_id_prev; // å½“å‰ä¿å­˜æ•°æ®çš„é¡µidï¼Œprevï¼ŒåŒä¸€ç»„æ•°æ®çš„å‰ä¸€é¡µï¼ˆä¸ºäº†è
             -Š‚çœç¨‹åºç©ºé—´ï¼Œä¸è¿›è¡Œåˆå§‹åŒ–ï¼Œç”±å‡½æ•°å†…éƒ¨èµ‹å€¼ï¼‰
 121   1          u8 cur_save_info_id_next; // å½“å‰ä¿å­˜æ•°æ®çš„é¡µidï¼Œnextï¼ŒåŒä¸€ç»„æ•°æ®çš„åä¸€é¡µ
 122   1      
 123   1          u8 cur_write_page_id = 0; // å­˜æ”¾å¾…å†™å…¥æ•°æ®çš„åœ°å€å¯¹åº”id
 124   1          u32 cur_erase_cnt;        // å­˜æ”¾è¯»å–åˆ°çš„æ“¦å†™æ¬¡æ•°
 125   1      
 126   1          /*
 127   1              å†™å…¥å‰ï¼Œè¯»å–ç›®å½•ï¼Œæ ¹æ®ç›®å½•æ‰¾åˆ°è¦å†™å…¥çš„åœ°å€
 128   1      
 129   1              å¦‚æœç›®å½•çš„æ•°æ®ä¸ä¸€è‡´ï¼Œä»¥æœ€åå†™å…¥çš„åœ°å€ä½œä¸ºæ–°å†™å…¥åœ°å€ï¼ˆç›®å½•ä¸­çš„ä¸¤ä¸
             -ªåœ°å€ï¼Œæœ€åå†™å…¥çš„åœ°å€åº”è¯¥å¤§äºå¦ä¸€ä¸ªåœ°å€ï¼‰
 130   1          */
 131   1      
 132   1          eeprom_menu_read();
 133   1      
 134   1          // if (eeprom_menu_prev.is_data_valid == EEPROM_DATA_VALID_VAL && eeprom_menu_next.is_data_valid == EE
             -PROM_DATA_VALID_VAL)
 135   1          if (eeprom_menu_prev.cur_write_page_id == eeprom_menu_next.cur_write_page_id)
 136   1          {
 137   2              cur_write_page_id = eeprom_menu_prev.cur_write_page_id;
 138   2          }
 139   1          else
 140   1          {
 141   2              // å¦‚æœç›®å½•ä¸­çš„æ•°æ®ä¸ä¸€è‡´ï¼Œåˆ¤æ–­å“ªä¸ªåœ°å€æ›´å¤§ï¼Œå“ªä¸ªå°±ä½œä¸ºå¾…å†™å…¥çš„åœ°å
             -€çš„id
 142   2              if (eeprom_menu_prev.cur_write_page_id > eeprom_menu_next.cur_write_page_id)
 143   2              {
 144   3                  cur_write_page_id = eeprom_menu_prev.cur_write_page_id;
 145   3              }
 146   2              else
 147   2              {
 148   3                  cur_write_page_id = eeprom_menu_next.cur_write_page_id;
 149   3              }
 150   2          }
 151   1      
 152   1          /*
 153   1              page[0]å’Œpage[1]å·²ç»ä½œä¸ºç›®å½•ä½¿ç”¨ï¼ˆid==0å’Œid==1ï¼‰ï¼Œ
 154   1              å‰©ä¸‹çš„é¡µé¢ï¼Œæ¯ä¸¤ä¸ªé¡µé¢ä½œä¸ºä¸€ç»„æ•°æ®ï¼Œ
 155   1              é‚£ä¹ˆå¶æ•°é¡µé¢ä½œä¸ºåŒä¸€ç»„é¡µé¢çš„å‰ä¸€ä¸ªé¡µé¢ï¼Œå¥‡æ•°é¡µé¢ä½œä¸ºåŒä¸€ç»„é¡µé¢çš„å
             -ä¸€ä¸ªé¡µé¢
 156   1      
 157   1              ä¾‹å¦‚ id == 2 ä½œä¸ºç¬¬ 1 ç»„é¡µé¢çš„å‰ä¸€ä¸ªé¡µé¢ prevï¼Œ
 158   1                  id == 3 ä½œä¸ºç¬¬ 1 ç»„é¡µé¢çš„åä¸€ä¸ªé¡µé¢ next
 159   1          */
 160   1          if (cur_write_page_id % 2 == 0)
 161   1          {
 162   2              /*
 163   2                  å¦‚æœå¾—åˆ°çš„æ˜¯å¶æ•°é¡µé¢ï¼Œ
 164   2                  å¾—åˆ°çš„å¶æ•°ï¼Œä½œä¸ºåŒä¸€ç»„é¡µé¢çš„ç¬¬ä¸€ä¸ªé¡µé¢ prev
 165   2                  å¾—åˆ°çš„å¶æ•° + 1ï¼Œä½œä¸ºåŒä¸€ç»„é¡µé¢çš„ç¬¬äºŒä¸ªé¡µé¢ next
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 4   

 166   2              */
 167   2              cur_save_info_id_prev = cur_write_page_id;
 168   2              cur_save_info_id_next = cur_write_page_id + 1;
 169   2          }
 170   1          else
 171   1          {
 172   2              /*
 173   2                  å¦‚æœå¾—åˆ°çš„æ˜¯å¥‡æ•°é¡µé¢ï¼Œ
 174   2      
 175   2                  å¾—åˆ°çš„å¥‡æ•° - 1ï¼Œä½œä¸ºåŒä¸€ç»„é¡µé¢çš„ç¬¬ä¸€ä¸ªé¡µé¢ prev
 176   2                  å¾—åˆ°çš„å¥‡æ•°ï¼Œä½œä¸ºåŒä¸€ç»„é¡µé¢çš„ç¬¬äºŒä¸ªé¡µé¢ next
 177   2              */
 178   2              cur_save_info_id_prev = cur_write_page_id - 1;
 179   2              cur_save_info_id_next = cur_write_page_id;
 180   2          }
 181   1      
 182   1          /*
 183   1              å¾—åˆ°åŒä¸€ç»„é¡µé¢çš„å‰ã€åä¸¤ä¸ªé¡µé¢çš„idåï¼Œè¯»å–è¿™ä¸¤ä¸ªé¡µé¢å¯¹åº”çš„æ•°æ®
 184   1      
 185   1              å°†ä¸¤ä¸ªé¡µé¢çš„æ•°æ®è¿›è¡Œæ¯”è¾ƒï¼Œ ç”¨æ€»é‡Œç¨‹è¾ƒå¤§çš„æ•°æ® è¦†ç›– æ€»é‡Œç¨‹è¾ƒå°çš„æ•°æ
             -®
 186   1      
 187   1              å¦‚æœè¶…è¿‡äº†é™åˆ¶çš„æ“¦å†™æ¬¡æ•°ï¼Œè¦æ¢ä¸‹ä¸€ç»„é¡µé¢ï¼Œå¹¶ä¸”æ›´æ–°åˆ°ç›®å½•ä¸­
 188   1              å¦‚æœå†™å®Œä¹‹åï¼Œè®°å½•çš„é¡µé¢idä¸ç›®å½•ä¸­çš„idä¸ä¸€è‡´ï¼Œè¦æ›´æ–°ç›®å½•ä¸­è®°å½•çš„é¡µé
             -¢id
 189   1          */
 190   1          eeprom_24cxx_read((cur_save_info_id_prev), (u8 *)&eeprom_saveinfo_prev, sizeof(eeprom_saveinfo_t));
 191   1          eeprom_24cxx_read((cur_save_info_id_next), (u8 *)&eeprom_saveinfo_next, sizeof(eeprom_saveinfo_t));
 192   1      
 193   1          // æ•°æ®æ— æ•ˆï¼Œå¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡è¯»å–ï¼Œæˆ–è€…ç”±äºå†™å…¥æ—¶æ‰ç”µå¯¼è‡´æ•°æ®ä¸¢å¤±
 194   1          if (eeprom_saveinfo_prev.is_data_valid != EEPROM_DATA_VALID_VAL)
 195   1          {
 196   2              eeprom_saveinfo_prev.erase_cnt = 0;
 197   2              eeprom_saveinfo_prev.total_mileage = 0;
 198   2              eeprom_saveinfo_prev.subtotal_mileage = 0;
 199   2              eeprom_saveinfo_prev.subtotal_mileage_2 = 0;
 200   2              eeprom_saveinfo_prev.is_data_valid = EEPROM_DATA_VALID_VAL;
 201   2          }
 202   1      
 203   1          // æ•°æ®æ— æ•ˆï¼Œå¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡è¯»å–ï¼Œæˆ–è€…ç”±äºå†™å…¥æ—¶æ‰ç”µå¯¼è‡´æ•°æ®ä¸¢å¤±
 204   1          if (eeprom_saveinfo_next.is_data_valid != EEPROM_DATA_VALID_VAL)
 205   1          {
 206   2              eeprom_saveinfo_next = eeprom_saveinfo_prev;
 207   2          }
 208   1      
 209   1          if (eeprom_saveinfo_prev.total_mileage < eeprom_saveinfo_next.total_mileage)
 210   1          {
 211   2              /*
 212   2                  å¦‚æœå‰ä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹è¦å°äºåä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹ï¼Œ
 213   2                  åä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹ åŠ ä¸Š æ–°å¢çš„æ€»é‡Œç¨‹å¢é‡ï¼Œå¾—åˆ°çš„æ€»é‡Œç¨‹ä¿å­˜åˆ°å‰ä¸
             -€ä¸ªé¡µé¢ä¸­ï¼Œ
 214   2                  åä¸€ä¸ªé¡µé¢ä½œä¸ºå¤‡ä»½ï¼Œä¹Ÿä¿å­˜ä¸‹æ¥
 215   2              */
 216   2              eeprom_saveinfo_next.total_mileage = fun_info.save_info.total_mileage;
 217   2              eeprom_saveinfo_next.subtotal_mileage = fun_info.save_info.subtotal_mileage;
 218   2              eeprom_saveinfo_next.subtotal_mileage_2 = fun_info.save_info.subtotal_mileage_2;
 219   2      
 220   2              cur_erase_cnt = eeprom_saveinfo_next.erase_cnt; // å­˜æ”¾æ“¦å†™æ¬¡æ•°
 221   2              eeprom_saveinfo_prev = eeprom_saveinfo_next;
 222   2          }
 223   1          else
 224   1          {
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 5   

 225   2              /*
 226   2                  å¦‚æœå‰ä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹è¦ å¤§äºæˆ–ç­‰äº åä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹ï¼Œ
 227   2                  å‰ä¸€ä¸ªé¡µé¢çš„æ€»é‡Œç¨‹ åŠ ä¸Š æ–°å¢çš„æ€»é‡Œç¨‹å¢é‡ï¼Œå¾—åˆ°çš„æ€»é‡Œç¨‹ä¿å­˜åˆ°åä¸
             -€ä¸ªé¡µé¢ä¸­ï¼Œ
 228   2                  å‰ä¸€ä¸ªé¡µé¢ä½œä¸ºå¤‡ä»½ï¼Œä¹Ÿä¿å­˜ä¸‹æ¥
 229   2              */
 230   2      
 231   2              eeprom_saveinfo_prev.total_mileage = fun_info.save_info.total_mileage;
 232   2              eeprom_saveinfo_prev.subtotal_mileage = fun_info.save_info.subtotal_mileage;
 233   2              eeprom_saveinfo_prev.subtotal_mileage_2 = fun_info.save_info.subtotal_mileage_2;
 234   2      
 235   2              cur_erase_cnt = eeprom_saveinfo_prev.erase_cnt; // å­˜æ”¾æ“¦å†™æ¬¡æ•°
 236   2              eeprom_saveinfo_next = eeprom_saveinfo_prev;
 237   2          }
 238   1      
 239   1          cur_erase_cnt++; // æ“¦å†™æ¬¡æ•°ç´¯åŠ 
 240   1          eeprom_saveinfo_prev.erase_cnt = cur_erase_cnt;
 241   1          eeprom_saveinfo_next.erase_cnt = cur_erase_cnt;
 242   1          if (cur_erase_cnt >= EEPROM_MAX_ERASE_COUNTS_PER_PAGE)
 243   1          {
 244   2              // å¦‚æœè¶…è¿‡äº†ä¸€ç»„é¡µé¢çš„æœ€å¤§æ“¦å†™æ¬¡æ•°ï¼Œæ›´æ¢ä¸‹ä¸€ç»„é¡µé¢
 245   2              cur_save_info_id_prev = cur_save_info_id_next + 1; // å½“å‰ä¸ºå¥‡æ•°idï¼ŒåŠ ä¸€ï¼Œä¸ºå¶æ•°idï¼Œæ
             -˜¯ä¸‹ä¸€ç»„é¡µé¢çš„ç¬¬ä¸€ä¸ªé¡µé¢
 246   2              cur_save_info_id_next = cur_save_info_id_prev + 1;
 247   2      
 248   2              // æ“¦å†™æ¬¡æ•°æ¸…é›¶
 249   2              eeprom_saveinfo_prev.erase_cnt = 0;
 250   2              eeprom_saveinfo_next.erase_cnt = 0;
 251   2          }
 252   1      
 253   1          eeprom_24cxx_write(cur_save_info_id_prev, (u8 *)&eeprom_saveinfo_prev, sizeof(eeprom_saveinfo_t));
 254   1          eeprom_24cxx_write(cur_save_info_id_next, (u8 *)&eeprom_saveinfo_next, sizeof(eeprom_saveinfo_t));
 255   1      
 256   1          /*
 257   1              å¦‚æœå†™å…¥çš„é¡µé¢idä¸ç›®å½•è®°å½•çš„idä¸ä¸€æ ·ï¼Œåˆ™æ›´æ–°ç›®å½•è®°å½•çš„id
 258   1          */
 259   1          if (cur_save_info_id_prev != eeprom_menu_prev.cur_write_page_id)
 260   1          {
 261   2              eeprom_menu_prev.cur_write_page_id = cur_save_info_id_prev;
 262   2              eeprom_menu_prev.is_data_valid = EEPROM_DATA_VALID_VAL;
 263   2      
 264   2              // eeprom_menu_next.cur_write_page_id = cur_save_info_id_prev;
 265   2              // eeprom_menu_next.is_data_valid = EEPROM_DATA_VALID_VAL;
 266   2      
 267   2              eeprom_menu_next = eeprom_menu_prev;
 268   2      
 269   2              eeprom_menu_write();
 270   2          }
 271   1      }
 272          
 273          static void delay_5us(u32 us)
 274          {
 275   1          u32 b = us * 1;
 276   1          // u32 b = us * 2;
 277   1          while (b--)
 278   1          {
 279   2          }
 280   1      }
 281          
 282          /**
 283           * @brief  iic start function
 284           * @param  None
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 6   

 285           * @retval None
 286           */
 287          void iic_start(void)
 288          {
 289   1          // èµ·å§‹æ—¶ï¼Œç³»ç»Ÿæ—¶é’Ÿçº¿ï¼ˆSCLKï¼‰å’Œç³»ç»Ÿæ•°æ®çº¿ï¼ˆSDATAï¼‰éƒ½å¤„äºé«˜ç”µå¹³
 290   1          SDA_OUT(); // SDAçº¿è¾“å‡º
 291   1          IIC_SDA = 1;
 292   1          IIC_SCL = 1;
 293   1          // å»¶æ—¶å‡½æ•°æ˜¯ä¸ºäº†ç­‰å¾…é…ç½®å®Œæˆï¼Œå½“SCLKä¸ºé«˜ç”µå¹³æ—¶ï¼ŒSDATAè·³å˜ä¸ºä½ç”µå¹³
 294   1          // ç´§æ¥ç€SCLKä¹Ÿè·³å˜ä¸ºä½ç”µå¹³
 295   1          // äº§ç”Ÿä¸€ä¸ªèµ·å§‹ä¿¡å·
 296   1          IIC_DELAY();
 297   1          IIC_SDA = 0; // START:when CLK is high,DATA change form high to low
 298   1          IIC_DELAY();
 299   1          IIC_SCL = 0;
 300   1      }
 301          
 302          /**
 303           * @brief  iic stop function
 304           * @param  None
 305           * @retval None
 306           */
 307          void iic_stop(void)
 308          {
 309   1          SDA_OUT(); // SDAçº¿è¾“å‡º
 310   1      
 311   1          // é…ç½®æ—¶é’Ÿçº¿å’Œæ•°æ®çº¿å‡ä¸ºä½ç”µå¹³
 312   1          IIC_SCL = 0;
 313   1          IIC_SDA = 0; // STOP:when CLK is high DATA change form low to high
 314   1          IIC_DELAY();
 315   1      
 316   1          // é…ç½®æ—¶é’Ÿçº¿ä¸ºé«˜ç”µå¹³
 317   1          IIC_SCL = 1;
 318   1          IIC_DELAY();
 319   1      
 320   1          // åœ¨æ—¶é’Ÿçº¿ä¸ºé«˜ç”µå¹³æ—¶ï¼Œè¾“å‡ºçš„æ•°æ®çº¿ä»ä½ç”µå¹³è·³å˜åˆ°é«˜ç”µå¹³ï¼Œåˆ™äº§ç”Ÿäº†åœæ­¢
             -ä¿¡å·
 321   1          IIC_SDA = 1;
 322   1          IIC_DELAY();
 323   1      }
 324          
 325          /**
 326           * @brief  wait ack function
 327           * @param  None
 328           * @retval 1:no ack 0:ack
 329           */
 330          u8 iic_wait_ack(void)
 331          {
 332   1          u8 timeout = 0;
 333   1      
 334   1          SDA_IN(); // SDAè®¾ç½®ä¸ºè¾“å…¥
 335   1      
 336   1          // é…ç½®ä¸ºé«˜ç”µå¹³
 337   1          IIC_SDA = 1;
 338   1          delay_5us(1);
 339   1      
 340   1          // é…ç½®ä¸ºé«˜ç”µå¹³
 341   1          IIC_SCL = 1;
 342   1          delay_5us(1);
 343   1      
 344   1          while (IIC_SDA)
 345   1          {
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 7   

 346   2              // ç­‰å¾…SDAæ‹‰ä½ï¼Œè¡¨ç¤ºåº”ç­”å¸¦æ¥ï¼Œä¸ç„¶ä¸€ç›´whileå¾ªç¯ï¼Œç›´åˆ°è¶…æ—¶
 347   2              timeout++;
 348   2              if (timeout > 250)
 349   2              {
 350   3                  iic_stop(); // ç­‰å¾…è¶…æ—¶ï¼Œåº”ç­”å¤±è´¥ï¼Œå‘å‡ºåœæ­¢ä¿¡å·
 351   3                  return 1;   // è¿”å›1ï¼Œè¡¨ç¤ºå¤±è´¥
 352   3              }
 353   2              IIC_DELAY();
 354   2          }
 355   1          IIC_SCL = 0; // SCLæ‹‰ä½
 356   1      
 357   1          return 0; // è¿”å›0ï¼Œè¡¨ç¤ºæˆåŠŸ
 358   1      }
 359          
 360          /**
 361           * @brief  iic ack function
 362           * @param  None
 363           * @retval None
 364           */
 365          void iic_ack(void)
 366          {
 367   1          IIC_SCL = 0;
 368   1          SDA_OUT();
 369   1          IIC_SDA = 0;
 370   1          delay_5us(1);
 371   1          IIC_SCL = 1;
 372   1          delay_5us(1);
 373   1          IIC_SCL = 0;
 374   1      }
 375          
 376          /**
 377           * @brief  iic no ack function
 378           * @param  None
 379           * @retval None
 380           */
 381          void iic_nack(void)
 382          {
 383   1          IIC_SCL = 0;
 384   1          SDA_OUT();
 385   1          IIC_SDA = 1;
 386   1          delay_5us(1);
 387   1          IIC_SCL = 1;
 388   1          delay_5us(1);
 389   1          IIC_SCL = 0;
 390   1      }
 391          
 392          /**
 393           * @brief  iic send 1 byte data function
 394           * @param  None
 395           * @retval 1:Ack 0:No Ack
 396           */
 397          void iic_send_byte(u8 txd)
 398          {
 399   1          u8 i;
 400   1      
 401   1          // é…ç½®P03ä¸ºè¾“å‡ºæ¨¡å¼
 402   1          SDA_OUT(); // SDAçº¿è¾“å‡ºæ¨¡å¼
 403   1      
 404   1          // åªæœ‰åœ¨æ—¶é’Ÿçº¿ä¸º0çš„æƒ…å†µä¸‹ï¼Œæ•°æ®çº¿æ‰å¯ä»¥è¿›è¡Œé«˜ä½ç”µå¹³çš„è·³å˜
 405   1          IIC_SCL = 0; // æ‹‰ä½æ—¶é’Ÿå¼€å§‹æ•°æ®ä¼ è¾“
 406   1      
 407   1          for (i = 0; i < 8; i++)
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 8   

 408   1          {                                // forå¾ªç¯ï¼Œä¸€ä½ä¸€ä½çš„å‘é€ï¼Œä»æœ€é«˜ä½ ä½7å¼€å§‹
 409   2              IIC_SDA = (txd & 0x80) >> 7; // é™¤äº†ä½7å¤–ï¼Œå…¶ä½™å…¨å±è”½ä¸º0ï¼Œç„¶åå³ç§»åˆ°ä½0ï¼Œç»™SDA
             -æ•°æ®çº¿
 410   2              txd <<= 1;                   // å·¦ç§»ä¸€ä½ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡å‘é€
 411   2              delay_5us(1);
 412   2      
 413   2              // å‘é€å®Œæˆä¹‹åï¼Œæ—¶é’Ÿçº¿æ‹‰é«˜
 414   2              IIC_SCL = 1;
 415   2              delay_5us(1);
 416   2      
 417   2              // ç´§æ¥ç€æ‹‰ä½
 418   2              IIC_SCL = 0;
 419   2              delay_5us(1);
 420   2      
 421   2              // å‘é€å®Œä¸€ä¸ªæ•°æ®éƒ½å°†æ—¶é’Ÿçº¿è¿›è¡Œä¸€æ¬¡çš„æ‹‰é«˜å’Œæ‹‰ä½ï¼Œå®Œæˆä¸€ä¸ªä½çš„ä¼ è¾“
 422   2          }
 423   1      }
 424          
 425          /**
 426           * @brief  iic read 1 byte function
 427           * @param  none
 428           * @retval ack=1,send ack=0;ack=0,send no ack
 429           */
 430          u8 iic_read_byte(unsigned char ack)
 431          {
 432   1          unsigned char i, receive = 0;
 433   1      
 434   1          SDA_IN(); // SDAè®¾ç½®ä¸ºè¾“å…¥
 435   1      
 436   1          for (i = 0; i < 8; i++)
 437   1          { // forå¾ªç¯ï¼Œä¸€ä½ä¸€ä½çš„è¯»å–ï¼Œä»æœ€é«˜ä½ ä½7å¼€å§‹
 438   2              IIC_SCL = 0;
 439   2              delay_5us(1);
 440   2              IIC_SCL = 1;
 441   2              receive <<= 1; // å·¦ç§»ä¸€ä½ï¼Œå‡†å¤‡ä¸‹æ¬¡çš„è¯»å–
 442   2      
 443   2              if (IIC_SDA)
 444   2              {
 445   3                  receive++;
 446   3              }
 447   2              delay_5us(1);
 448   2          }
 449   1      
 450   1          if (!ack)
 451   1          {               // ä¸éœ€è¦å‘é€
 452   2              iic_nack(); // å‘é€nACK
 453   2          }
 454   1          else
 455   1          {              // éœ€è¦å‘é€
 456   2              iic_ack(); // å‘é€ACK
 457   2          }
 458   1      
 459   1          return receive;
 460   1      }
 461          
 462          /**
 463           * @brief  åœ¨AT24CXXé‡Œé¢çš„æŒ‡å®šåœ°å€å¼€å§‹è¯»å‡ºæŒ‡å®šä¸ªæ•°çš„æ•°æ®
 464           * @param  addr : å¼€å§‹è¯»å‡ºçš„åœ°å€ å¯¹24c512ä¸º0~65535
 465           * @param  pBuffer  : æ•°æ®æ•°ç»„é¦–åœ°å€
 466           * @param  num_read_data: è¦è¯»å‡ºæ•°æ®çš„ä¸ªæ•°
 467           * @retval u8  0--æˆåŠŸï¼Œ1--å¤±è´¥
 468           */
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 9   

 469          u8 iic_eeprom_read(u16 addr, u8 *pBuffer, u16 num_read_data)
 470          {
 471   1          // èµ·å§‹ä¿¡å·
 472   1          iic_start();
 473   1      
 474   1          // å‘é€è®¾å¤‡åœ°å€
 475   1          // iic_send_byte(E2PROM_DEVICE_ADDR + ((device_addr / 256) << 1));
 476   1          iic_send_byte(E2PROM_DEVICE_ADDR | IIC_WRITE_CMD);
 477   1      
 478   1          // ç­‰å¾…åº”ç­”
 479   1          if (iic_wait_ack())
 480   1          {
 481   2              return 1;
 482   2          }
 483   1      
 484   1          // iic_send_byte(addr / 256 >> 8); // å‘é€é«˜åœ°å€
 485   1          iic_send_byte(addr >> 8); // å‘é€é«˜åœ°å€
 486   1      
 487   1          // ç­‰å¾…åº”ç­”
 488   1          if (iic_wait_ack())
 489   1          {
 490   2              return 1;
 491   2          }
 492   1      
 493   1          // iic_send_byte(addr % 256); // å‘é€ä½åœ°å€
 494   1          iic_send_byte(addr & 0xFF); // å‘é€ä½åœ°å€
 495   1      
 496   1          // ç­‰å¾…åº”ç­”
 497   1          if (iic_wait_ack())
 498   1          {
 499   2              return 1;
 500   2          }
 501   1      
 502   1          IIC_DELAY();
 503   1      
 504   1          // èµ·å§‹ä¿¡å·
 505   1          iic_start();
 506   1          iic_send_byte(E2PROM_DEVICE_ADDR | IIC_READ_CMD); // è¿›å…¥æ¥æ”¶æ¨¡å¼
 507   1      
 508   1          // ç­‰å¾…åº”ç­”
 509   1          if (iic_wait_ack())
 510   1          {
 511   2              return 1;
 512   2          }
 513   1      
 514   1          num_read_data--;
 515   1          while (num_read_data)
 516   1          {
 517   2              *pBuffer++ = iic_read_byte(1);
 518   2              num_read_data--;
 519   2          }
 520   1          *pBuffer = iic_read_byte(0);
 521   1          // åœæ­¢ä¿¡å·
 522   1          iic_stop(); // äº§ç”Ÿä¸€ä¸ªåœæ­¢æ¡ä»¶
 523   1      
 524   1          return 0;
 525   1      }
 526          
 527          /**
 528           * @brief  åœ¨AT24CXXé‡Œé¢çš„æŒ‡å®šåœ°å€å¼€å§‹å†™å…¥æŒ‡å®šä¸ªæ•°çš„æ•°æ®
 529           * @param  addr : å¼€å§‹å†™å…¥çš„åœ°å€ å¯¹24c512ä¸º0~65535
 530           * @param  pBuffer   : æ•°æ®æ•°ç»„é¦–åœ°å€
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 10  

 531           * @param  num_write_data: è¦å†™å…¥æ•°æ®çš„ä¸ªæ•°
 532           * @retval 0--æ“ä½œæˆåŠŸï¼Œ1--æ“ä½œå¤±è´¥
 533           */
 534          u8 iic_eeprom_write(u16 addr, u8 *pBuffer, u16 num_write_data)
 535          {
 536   1          // æ€»çº¿å‘é€ä¸€ä¸ªå¼€å§‹ä¿¡å·
 537   1          iic_start();
 538   1      
 539   1          // å‘é€è®¾å¤‡åœ°å€
 540   1          // iic_send_byte(E2PROM_DEVICE_ADDR + ((device_addr / 256) << 1));
 541   1          iic_send_byte(E2PROM_DEVICE_ADDR | IIC_WRITE_CMD);
 542   1      
 543   1          // åº”ç­”ä¿¡å·ï¼Œç­‰å¾…ä»æœºåº”ç­”
 544   1          if (iic_wait_ack())
 545   1          {
 546   2              return 1; // è¡¨ç¤ºæ“ä½œå¤±è´¥ï¼Œæ²¡æœ‰æ”¶åˆ°åº”ç­”
 547   2          }
 548   1      
 549   1          // iic_send_byte(addr / 256 >> 8); // å‘é€é«˜åœ°å€
 550   1          iic_send_byte(addr >> 8); // å‘é€é«˜åœ°å€
 551   1      
 552   1          // åº”ç­”ä¿¡å·ï¼Œç­‰å¾…ä»æœºåº”ç­”
 553   1          if (iic_wait_ack())
 554   1          {
 555   2              return 1; // è¡¨ç¤ºæ“ä½œå¤±è´¥ï¼Œæ²¡æœ‰æ”¶åˆ°åº”ç­”
 556   2          }
 557   1      
 558   1          // iic_send_byte(addr % 256); // å‘é€ä½åœ°å€
 559   1          iic_send_byte(addr & 0xFF); // å‘é€ä½åœ°å€
 560   1      
 561   1          // åº”ç­”ä¿¡å·ï¼Œç­‰å¾…ä»æœºåº”ç­”
 562   1          if (iic_wait_ack())
 563   1          {
 564   2              return 1; // è¡¨ç¤ºæ“ä½œå¤±è´¥ï¼Œæ²¡æœ‰æ”¶åˆ°åº”ç­”
 565   2          }
 566   1      
 567   1          while (num_write_data--)
 568   1          {
 569   2              iic_send_byte(*pBuffer); // å‘é€å­—èŠ‚
 570   2              if (iic_wait_ack())
 571   2              {
 572   3                  return 1; // è¡¨ç¤ºæ“ä½œå¤±è´¥ï¼Œæ²¡æœ‰æ”¶åˆ°åº”ç­”
 573   3              }
 574   2      
 575   2              addr++;
 576   2              pBuffer++;
 577   2          }
 578   1      
 579   1          delay_5us(1);
 580   1          // æ€»çº¿å‘é€ä¸€ä¸ªåœæ­¢ä¿¡å·
 581   1          iic_stop(); // äº§ç”Ÿä¸€ä¸ªåœæ­¢æ¡ä»¶
 582   1      
 583   1          return 0; // è¡¨ç¤ºæ“ä½œæˆåŠŸ
 584   1      }
 585          
 586          void eeprom_24cxx_write(u8 page_id, u8 *p_buf, u16 len)
 587          {
 588   1          u16 addr = EEPROM_PAGE_X_ADDR(page_id);
 589   1      
 590   1          while (iic_eeprom_write(addr, p_buf, len))
 591   1          {
 592   2              // printf("time out\n");
C51 COMPILER V9.60.7.0   IIC_SOFT                                                          08/06/2025 17:46:19 PAGE 11  

 593   2          };
 594   1      }
 595          
 596          void eeprom_24cxx_read(u8 page_id, u8 *p_buf, u16 len)
 597          {
 598   1          u16 addr = EEPROM_PAGE_X_ADDR(page_id);
 599   1          while (iic_eeprom_read(addr, p_buf, len))
 600   1              ;
 601   1      }
 602          
 603          void iic_config(void)
 604          {
 605   1          // åˆå§‹åŒ–IIC
 606   1          IIC_SDA = 1; // è®¾ç½®ä¸ºé«˜ç”µå¹³
 607   1          IIC_SCL = 1; // è®¾ç½®ä¸ºé«˜ç”µå¹³
 608   1      
 609   1          // P1_PU |= GPIO_P16_PULL_UP(0x01);
 610   1          // P2_PU |= GPIO_P25_PULL_UP(0x01);
 611   1      
 612   1          // P1_MD1 &= ~GPIO_P16_MODE_SEL(0x3); // æ¸…é›¶
 613   1          // P1_MD1 |= GPIO_P16_MODE_SEL(0x1);  // é…ç½®ä¸ºè¾“å‡ºæ¨¡å¼ï¼šDATA
 614   1      
 615   1          // P2_MD1 &= ~GPIO_P25_MODE_SEL(0x3); // æ¸…é›¶
 616   1          // P2_MD1 |= GPIO_P25_MODE_SEL(0x1);  // é…ç½®ä¸ºè¾“å‡ºæ¨¡å¼ï¼šCLK
 617   1      
 618   1          P1_MD1 &= ~GPIO_P17_MODE_SEL(0x3); // æ¸…ç©ºé…ç½®
 619   1          P1_MD1 |= GPIO_P17_MODE_SEL(0x1);  // è¾“å‡ºæ¨¡å¼
 620   1          FOUT_S17 = GPIO_FOUT_AF_FUNC;
 621   1          P17 = 0;
 622   1          // P17 = 1;
 623   1      
 624   1          P1_MD1 &= ~GPIO_P16_MODE_SEL(0x03);
 625   1          P1_MD1 |= GPIO_P16_MODE_SEL(0x1);
 626   1          FOUT_S16 = GPIO_FOUT_AF_FUNC;
 627   1      
 628   1          P2_MD1 &= ~GPIO_P24_MODE_SEL(0x03);
 629   1          P2_MD1 |= GPIO_P24_MODE_SEL(0x1);
 630   1          FOUT_S24 = GPIO_FOUT_AF_FUNC;
 631   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1736    ----
   CONSTANT SIZE    =    448    ----
   XDATA SIZE       =     57      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
