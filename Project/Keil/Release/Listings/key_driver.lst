C51 COMPILER V9.60.7.0   KEY_DRIVER                                                        08/07/2025 17:46:20 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE KEY_DRIVER
OBJECT MODULE PLACED IN .\Release\Objects\key_driver.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\key_driver.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTO
                    -R(0X000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(
                    -.\Release\Listings\key_driver.lst) OBJECT(.\Release\Objects\key_driver.obj)

line level    source

   1          #include "key_driver.h"
   2          
   3          #if (TOUCH_KEY_ENABLE || AD_KEY_ENABLE)
   4          
   5          enum
   6          {
   7              KEY_SCAN_STATUS_NONE = 0,       // æ— ç‰¹æ®ŠçŠ¶æ€
   8              KEY_SCAN_STATUS_TO_NOTIFY,      // å‘é€æŒ‰é”®æ¶ˆæ¯
   9              KEY_SCAN_STATUS_TO_END_OF_SCAN, // æŒ‰é”®æ‰«æç»“æŸï¼Œè¿›è¡Œæ”¶å°¾å¤„ç†
  10          };
  11          
  12          static volatile u8 is_key_active; // æŒ‰é”®æ˜¯å¦æœ‰æ•ˆçš„è®¡æ•°å€¼
  13          
  14          //=======================================================//
  15          // æŒ‰é”®æ‰«æå‡½æ•°: æ‰«ææ‰€æœ‰æ³¨å†Œçš„æŒ‰é”®é©±åŠ¨
  16          //=======================================================//
  17          // xdata volatile struct key_driver_para *scan_para; // è¦è®©æŒ‡é’ˆæŒ‡å‘xdataåŒºåŸŸçš„å…¨å±€å˜é‡ï¼Œéœ€
             -è¦åŒæ ·å°†æŒ‡é’ˆå˜ä¸ºå…¨å±€å˜é‡
  18          volatile struct key_driver_para *scan_para; // è¦è®©æŒ‡é’ˆæŒ‡å‘xdataåŒºåŸŸçš„å…¨å±€å˜é‡ï¼Œéœ€è¦åŒæ ·
             -å°†æŒ‡é’ˆå˜ä¸ºå…¨å±€å˜é‡
  19          void key_driver_scan(void *_scan_para)
  20          // struct key_driver_para key_driver_scan(struct key_driver_para scan_para)
  21          {
  22   1          // volatile struct key_driver_para xdata *scan_para = (struct key_driver_para xdata *)_scan_para; // å
             -‡½æ•°å†…éƒ¨çš„æŒ‡é’ˆåªèƒ½æŒ‡å‘idataç©ºé—´ï¼Œä¸èƒ½æŒ‡å‘å…¨å±€å˜é‡çš„xdataç©ºé—´
  23   1          // volatile struct key_driver_para xdata *scan_para = (struct key_driver_para xdata *)0x642D; // ç³»ç»
             -Ÿä¼šä¸€ç›´å¤ä½
  24   1      
  25   1      #if 1
  26   1          u8 key_event = KEY_EVENT_NONE; // å­˜æ”¾å¾…å‘é€çš„æŒ‰é”®äº‹ä»¶
  27   1          u8 cur_key_value = NO_KEY;     // å­˜æ”¾å¾…å‘é€çš„æŒ‰é”®é”®å€¼
  28   1          u8 key_value = NO_KEY;
  29   1      
  30   1          // u8 key_scan_status = KEY_SCAN_STATUS_NONE; // çŠ¶æ€æœºï¼Œè´Ÿè´£æŽ§åˆ¶è¯¥å‡½æ•°å†…çš„è·³è½¬æ“ä½œ /
             -* æŽ§åˆ¶è·³è½¬è¿˜æœ‰é—®é¢˜ï¼Œè¿˜ä¸èƒ½ä½¿ç”¨ */
  31   1      
  32   1          scan_para = (struct key_driver_para *)_scan_para;
  33   1      
  34   1          // å¦‚æžœæ‰«ææ—¶é—´æœªåˆ°æ¥ï¼Œä¸æ‰§è¡ŒæŒ‰é”®æ‰«æ
  35   1          if (scan_para->cur_scan_times < scan_para->scan_times)
  36   1          {
  37   2              return;
  38   2          }
  39   1      
  40   1          scan_para->cur_scan_times = 0; // æ¸…ç©ºæ‰«ææ—¶é—´
  41   1      
  42   1          cur_key_value = scan_para->get_value(); // è°ƒç”¨ç”¨æˆ·è‡ªå®šä¹‰çš„èŽ·å–é”®å€¼å‡½æ•°
  43   1      
  44   1          // if (cur_key_value != NO_KEY)
  45   1          //     printf("key id %bu\n", cur_key_value); // æ‰“å°èŽ·å–åˆ°çš„é”®å€¼
  46   1      
  47   1          // åˆ¤æ–­æŒ‰é”®æ˜¯å¦æœ‰æ•ˆ
  48   1          if (cur_key_value != NO_KEY)
C51 COMPILER V9.60.7.0   KEY_DRIVER                                                        08/07/2025 17:46:20 PAGE 2   

  49   1          {
  50   2              is_key_active = 35; // 35*10Ms
  51   2          }
  52   1          else if (is_key_active)
  53   1          {
  54   2              is_key_active--;
  55   2          }
  56   1      
  57   1          // if (cur_key_value != NO_KEY)
  58   1          // {
  59   1          //     //     printf("scan_times %bu\n", scan_para->scan_times);
  60   1          //     //     printf("cur_scan_times %bu\n", scan_para->cur_scan_times);
  61   1          //     //     printf("last_key %bu\n", scan_para->last_key);
  62   1          //     //     printf("filter_value %bu\n", scan_para->filter_value);
  63   1          //     //     printf("filter_cnt %bu\n", scan_para->filter_cnt);
  64   1          //     //     printf("filter_time %bu\n", scan_para->filter_time);
  65   1          //     printf("long_time %bu\n", ad_key_para.long_time);
  66   1          //     printf("long_time %bu\n", (*scan_para).long_time);
  67   1          //     //     printf("hold_time %bu\n", scan_para->hold_time);
  68   1          //     //     printf("press_cnt %bu\n", scan_para->press_cnt);
  69   1      
  70   1          //     //     printf("click_cnt %bu\n", scan_para->click_cnt);
  71   1          //     //     printf("click_delay_cnt %bu\n", scan_para->click_delay_cnt);
  72   1          //     //     printf("click_delay_time %bu\n", scan_para->click_delay_time);
  73   1          //     //     printf("notify_value %bu\n", scan_para->notify_value);
  74   1          //     //     printf("key_type %bu\n", scan_para->key_type);
  75   1      
  76   1          //     //     printf("latest_key_val %bu\n", scan_para->latest_key_val);
  77   1          //     //     printf("latest_key_event %bu\n", scan_para->latest_key_event);
  78   1      
  79   1          //     printf("ad key long time addr %p\n", &ad_key_para.long_time);
  80   1          //     // printf("scan para long time addr %p\n", &(scan_para->long_time));
  81   1          //     printf("scan para long time addr %p\n", (*scan_para).long_time);
  82   1          // }
  83   1      
  84   1          //===== æŒ‰é”®æ¶ˆæŠ–å¤„ç†
  85   1          if (cur_key_value != scan_para->filter_value && scan_para->filter_time)
  86   1          {
  87   2              // å½“å‰æŒ‰é”®å€¼ä¸Žä¸Šä¸€æ¬¡æŒ‰é”®å€¼å¦‚æžœä¸ç›¸ç­‰, é‡æ–°æ¶ˆæŠ–å¤„ç†, æ³¨æ„filter_time != 0
             -;
  88   2              scan_para->filter_cnt = 0;               // æ¶ˆæŠ–æ¬¡æ•°æ¸…0, é‡æ–°å¼€å§‹æ¶ˆæŠ–
  89   2              scan_para->filter_value = cur_key_value; // è®°å½•ä¸Šä¸€æ¬¡çš„æŒ‰é”®å€¼
  90   2              return;                                  // ç¬¬ä¸€æ¬¡æ£€æµ‹, è¿”å›žä¸åšå¤„ç†
  91   2          }
  92   1      
  93   1          // å½“å‰æŒ‰é”®å€¼ä¸Žä¸Šä¸€æ¬¡æŒ‰é”®å€¼ç›¸ç­‰, filter_cntå¼€å§‹ç´¯åŠ ;
  94   1          if (scan_para->filter_cnt < scan_para->filter_time)
  95   1          {
  96   2              scan_para->filter_cnt++;
  97   2              return;
  98   2          }
  99   1      
 100   1          //===== æŒ‰é”®æ¶ˆæŠ–ç»“æŸ, å¼€å§‹åˆ¤æ–­æŒ‰é”®ç±»åž‹(å•å‡», åŒå‡», é•¿æŒ‰, å¤šå‡», HOLD, (é•¿æŒ‰/HOL
             -D)æŠ¬èµ·)
 101   1          if (cur_key_value != scan_para->last_key)
 102   1          {
 103   2              /*
 104   2                  å¦‚æžœå½“å‰çš„é”®å€¼ä¸ºç©ºï¼Œä¸Šä¸€æ¬¡çš„é”®å€¼åˆä¸Žå½“å‰çš„é”®å€¼ä¸ä¸€æ ·ï¼Œè¯´æ˜ŽæŒ‰é”®æ
             -¾å¼€
 105   2                  cur_key = NO_KEY; last_key = valid_key -> æŒ‰é”®è¢«æŠ¬èµ·
 106   2              */
 107   2              // printf("key event up\n");
C51 COMPILER V9.60.7.0   KEY_DRIVER                                                        08/07/2025 17:46:20 PAGE 3   

 108   2      
 109   2              if (cur_key_value == NO_KEY)
 110   2              {
 111   3                  if (scan_para->press_cnt >= scan_para->long_time)
 112   3                  { // é•¿æŒ‰/HOLDçŠ¶æ€ä¹‹åŽè¢«æŒ‰é”®æŠ¬èµ·;
 113   4                      key_event = KEY_EVENT_UP;
 114   4                      key_value = scan_para->last_key;
 115   4                      goto _notify; // å‘é€æŠ¬èµ·æ¶ˆæ¯
 116   4                      // key_scan_status = KEY_SCAN_STATUS_TO_NOTIFY; // è·³è½¬åˆ°å‘é€æŒ‰é”®äº‹ä»¶çš„æ“ä½œ
 117   4                  }
 118   3      
 119   3                  // if (KEY_SCAN_STATUS_NONE == key_scan_status) // å¦‚æžœæ²¡æœ‰ç‰¹æ®Šæ“ä½œ
 120   3                  {
 121   4                      scan_para->click_delay_cnt = 1; // æŒ‰é”®ç­‰å¾…ä¸‹æ¬¡è¿žå‡»å»¶æ—¶å¼€å§‹
 122   4                  }
 123   3              }
 124   2              else
 125   2              {
 126   3                  /*
 127   3                      å¦‚æžœå½“å‰çš„é”®å€¼ä¸ä¸ºç©ºï¼Œä¸Šä¸€æ¬¡çš„é”®å€¼åˆä¸Žå½“å‰çš„é”®å€¼ä¸ä¸€æ ·ï¼Œè¯´æ˜Ž
             -æŒ‰é”®æŒ‰ä¸‹
 128   3                      cur_key = valid_key, last_key = NO_KEY -> æŒ‰é”®è¢«æŒ‰ä¸‹
 129   3                  */
 130   3                  scan_para->press_cnt = 1; // ç”¨äºŽåˆ¤æ–­longå’Œholdäº‹ä»¶çš„è®¡æ•°å™¨é‡æ–°å¼€å§‹è®¡æ—¶;
 131   3                  if (cur_key_value != scan_para->notify_value)
 132   3                  { // ç¬¬ä¸€æ¬¡å•å‡»/è¿žå‡»æ—¶æŒ‰ä¸‹çš„æ˜¯ä¸åŒæŒ‰é”®, å•å‡»æ¬¡æ•°é‡æ–°å¼€å§‹è®¡æ•°
 133   4                      scan_para->click_cnt = 1;
 134   4                      scan_para->notify_value = cur_key_value;
 135   4                  }
 136   3                  else
 137   3                  {
 138   4                      scan_para->click_cnt++; // å•å‡»æ¬¡æ•°ç´¯åŠ 
 139   4                  }
 140   3              }
 141   2      
 142   2              goto _scan_end; // è¿”å›ž, ç­‰å¾…å»¶æ—¶æ—¶é—´åˆ°
 143   2              // if (KEY_SCAN_STATUS_NONE == key_scan_status)
 144   2              // {
 145   2              //     key_scan_status = KEY_SCAN_STATUS_TO_END_OF_SCAN; // è¿”å›ž, ç­‰å¾…å»¶æ—¶æ—¶é—´åˆ°
 146   2              // }
 147   2          }
 148   1          else
 149   1          {
 150   2              /*
 151   2                  å¦‚æžœå½“å‰èŽ·å–çš„é”®å€¼ä¸Žä¸Šæ¬¡èŽ·å–çš„é”®å€¼ä¸€æ ·ï¼Œè¯´æ˜ŽæŒ‰é”®åœ¨é•¿æŒ‰æˆ–æ˜¯æŒ‰é”®æ
             -œªæŒ‰ä¸‹
 152   2                  cur_key = last_key -> æ²¡æœ‰æŒ‰é”®æŒ‰ä¸‹/æŒ‰é”®é•¿æŒ‰(HOLD)
 153   2              */
 154   2              if (cur_key_value == NO_KEY)
 155   2              {
 156   3                  // last_key = NO_KEY; cur_key = NO_KEY -> æ²¡æœ‰æŒ‰é”®æŒ‰ä¸‹
 157   3                  if (scan_para->click_cnt > 0)
 158   3                  { // æœ‰æŒ‰é”®éœ€è¦æ¶ˆæ¯éœ€è¦å¤„ç†
 159   4      
 160   4                      // å¦‚æžœåªå“åº”å•å‡»äº‹ä»¶ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ /ä¿®æ”¹åŠŸèƒ½
 161   4      
 162   4                      if (scan_para->click_delay_cnt > scan_para->click_delay_time)
 163   4                      { // æŒ‰é”®è¢«æŠ¬èµ·åŽå»¶æ—¶åˆ°
 164   5                          // TODO: åœ¨æ­¤å¯ä»¥æ·»åŠ ä»»æ„å¤šå‡»äº‹ä»¶
 165   5                          // if (scan_para->click_cnt >= 5)
 166   5                          // {
 167   5                          //     key_event = KEY_EVENT_FIRTH_CLICK; // äº”å‡»
C51 COMPILER V9.60.7.0   KEY_DRIVER                                                        08/07/2025 17:46:20 PAGE 4   

 168   5                          // }
 169   5                          // else if (scan_para->click_cnt >= 4)
 170   5                          // {
 171   5                          //     key_event = KEY_EVENT_FOURTH_CLICK; // 4å‡»
 172   5                          // }
 173   5                          // else if (scan_para->click_cnt >= 3)
 174   5                          // {
 175   5                          //     key_event = KEY_EVENT_TRIPLE_CLICK; // ä¸‰å‡»
 176   5                          // }
 177   5                          // else if (scan_para->click_cnt >= 2)
 178   5                          // if (scan_para->click_cnt >= 2)
 179   5                          // {
 180   5                          //     key_event = KEY_EVENT_DOUBLE_CLICK; // åŒå‡»
 181   5                          // }
 182   5                          // else
 183   5                          {
 184   6                              key_event = KEY_EVENT_CLICK; // å•å‡»
 185   6                              // printf("click \n");
 186   6                          }
 187   5                          key_value = scan_para->notify_value;
 188   5      
 189   5                          goto _notify;
 190   5                          // key_scan_status = KEY_SCAN_STATUS_TO_NOTIFY;
 191   5                      }
 192   4                      else
 193   4                      { // æŒ‰é”®æŠ¬èµ·åŽç­‰å¾…ä¸‹æ¬¡å»¶æ—¶æ—¶é—´æœªåˆ°
 194   5                          scan_para->click_delay_cnt++;
 195   5                          goto _scan_end; // æŒ‰é”®æŠ¬èµ·åŽå»¶æ—¶æ—¶é—´æœªåˆ°, è¿”å›ž
 196   5                          // key_scan_status = KEY_SCAN_STATUS_TO_END_OF_SCAN;
 197   5                      }
 198   4                  }
 199   3                  else
 200   3                  {
 201   4                      goto _scan_end; // æ²¡æœ‰æŒ‰é”®éœ€è¦å¤„ç†
 202   4                      // key_scan_status = KEY_SCAN_STATUS_TO_END_OF_SCAN;
 203   4                  }
 204   3              }
 205   2              else
 206   2              {
 207   3                  // last_key = valid_key; cur_key = valid_key, press_cntç´¯åŠ ç”¨äºŽåˆ¤æ–­longå’Œhold
 208   3                  if (scan_para->press_cnt < 255)
 209   3                  {
 210   4                      scan_para->press_cnt++;
 211   4                  }
 212   3      
 213   3                  // printf("long time %bu\n", scan_para->long_time);
 214   3                  // printf("press cnt %bu\n", scan_para->press_cnt);
 215   3                  if (scan_para->press_cnt == scan_para->long_time)
 216   3                  {
 217   4                      key_event = KEY_EVENT_LONG;
 218   4      
 219   4                      // printf("long time %bu\n", scan_para->long_time);
 220   4      
 221   4                      // printf("key event long\n");
 222   4                  }
 223   3                  else if (scan_para->press_cnt == scan_para->hold_time)
 224   3                  {
 225   4                      key_event = KEY_EVENT_HOLD;
 226   4                      scan_para->press_cnt = scan_para->long_time; // ä¸‹ä¸€æ¬¡scan_para->press_cnt++,è¿˜æ˜¯ä¼šè
             -¿›å…¥åˆ°è¿™é‡Œ
 227   4                      // printf("key event hold\n");
 228   4                  }
C51 COMPILER V9.60.7.0   KEY_DRIVER                                                        08/07/2025 17:46:20 PAGE 5   

 229   3                  else
 230   3                  {
 231   4                      goto _scan_end; // press_cntæ²¡åˆ°é•¿æŒ‰å’ŒHOLDæ¬¡æ•°, è¿”å›ž
 232   4                      // key_scan_status = KEY_SCAN_STATUS_TO_END_OF_SCAN;
 233   4                  }
 234   3      
 235   3                  // press_cntæ²¡åˆ°é•¿æŒ‰å’ŒHOLDæ¬¡æ•°, å‘æ¶ˆæ¯
 236   3                  key_value = cur_key_value;
 237   3                  goto _notify;
 238   3                  // key_scan_status = KEY_SCAN_STATUS_TO_NOTIFY;
 239   3              }
 240   2          }
 241   1      
 242   1      _notify:
 243   1      
 244   1          // if (KEY_SCAN_STATUS_TO_END_OF_SCAN != key_scan_status)
 245   1          {
 246   2              // if (KEY_TYPE_AD == scan_para->key_type) // å¦‚æžœæ˜¯adæŒ‰é”®
 247   2              {
 248   3                  scan_para->click_cnt = 0;         // æŒ‰ä¸‹æ¬¡æ•°æ¸…0
 249   3                  scan_para->notify_value = NO_KEY; // åœ¨å»¶æ—¶çš„å¾…å‘é€æŒ‰é”®å€¼æ¸…é›¶
 250   3      
 251   3                  scan_para->latest_key_val = key_value;   // å­˜æ”¾å¾—åˆ°çš„æŒ‰é”®é”®å€¼
 252   3                  scan_para->latest_key_event = key_event; // å­˜æ”¾å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶
 253   3      
 254   3                  // printf("notify\n");
 255   3              }
 256   2              // else if (KEY_TYPE_TOUCH == scan_para->key_type) // å¦‚æžœæ˜¯è§¦æ‘¸æŒ‰é”®
 257   2              // {
 258   2              //     scan_para->click_cnt = 0;         // æŒ‰ä¸‹æ¬¡æ•°æ¸…0
 259   2              //     scan_para->notify_value = NO_KEY; // åœ¨å»¶æ—¶çš„å¾…å‘é€æŒ‰é”®å€¼æ¸…é›¶
 260   2      
 261   2              //     scan_para->latest_key_val = key_value;   // å­˜æ”¾å¾—åˆ°çš„æŒ‰é”®é”®å€¼
 262   2              //     scan_para->latest_key_event = key_event; // å­˜æ”¾å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶
 263   2              // }
 264   2          }
 265   1      
 266   1      _scan_end:
 267   1          scan_para->last_key = cur_key_value;
 268   1          return;
 269   1      #endif
 270   1      }
 271          
 272          #endif // #if (TOUCH_KEY_ENABLE  || AD_KEY_ENABLE)


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    436    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
