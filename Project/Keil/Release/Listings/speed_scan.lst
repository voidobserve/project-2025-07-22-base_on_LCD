C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        07/11/2025 11:11:28 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\speed_scan.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X
                    -000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Re
                    -lease\Listings\speed_scan.lst) OBJECT(.\Release\Objects\speed_scan.obj)

line level    source

   1          #include "speed_scan.h"
   2          
   3          #if 0
              // æ ‡å¿—ä½ï¼Œæ˜¯å¦ç”±æ›´æ–°è®¡æ•°,ç”±å®šæ—¶å™¨æ¥ç½®ä½
              // 0--æœªæ›´æ–°è„‰å†²è®¡æ•°ï¼Œ1--æœ‰æ–°çš„è„‰å†²è®¡æ•°
              volatile bit flag_is_update_speed_pulse_cnt = 0;
              volatile u16 speed_scan_time_cnt = 0;        // é€Ÿåº¦æ‰«ææ—¶ï¼Œç”¨åˆ°çš„æ—¶é—´è®¡æ•°å€¼ï¼Œä¼šåœ¨å®šæ—¶å
             -™¨ä¸­æ–­ä¸­ç´¯åŠ 
              volatile u16 speed_actual_scan_time_cnt = 0; // å­˜æ”¾å®é™…çš„é€Ÿåº¦æ‰«ææ—¶é—´(å®é™…çš„é€Ÿåº¦æ‰«æç”¨
             -æ—¶)
              // volatile u32 detect_speed_pulse_cnt = 0; // æ£€æµ‹æ—¶é€Ÿçš„è„‰å†²è®¡æ•°å€¼(ç”¨IOä¸­æ–­æ¥æ£€æµ‹)
              /*
                  å­˜æ”¾ æ£€æµ‹åˆ°çš„æ—¶é€Ÿè„‰å†²è®¡æ•°å€¼ï¼Œä¼šåœ¨ä¸­æ–­å†…ç´¯åŠ 
                  ä½¿ç”¨äº†åŒç¼“å†²ï¼Œ[0]ç”¨åœ¨å®šæ—¶å™¨ä¸­æ–­ä¸­ï¼Œ[1]ç”¨åœ¨å¤„ç†å‡½æ•°ä¸­
                  å½“ flag_is_update_speed_pulse_cnt == 1æ—¶ï¼Œè¯´æ˜å·²ç»æœ‰æ•°æ®æ›´æ–°
              */
              volatile u32 detect_speed_pulse_cnt[2] = {0}; // æ£€æµ‹æ—¶é€Ÿçš„è„‰å†²è®¡æ•°å€¼
              #endif
  17          
  18          
  19          // æ—¶é€Ÿæ‰«æçš„é…ç½®
  20          void speed_scan_config(void)
  21          {
  22   1      #if 1 // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³å˜åŒ–æ¥è®¡ç®—è„‰å†²
  23   1      
  24   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x3); // è¾“å…¥æ¨¡å¼
  25   1          P1_PU |= GPIO_P15_PULL_UP(0x1);    // é…ç½®ä¸ºä¸Šæ‹‰
  26   1      
  27   1      #endif // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³å˜åŒ–æ¥è®¡ç®—è„‰å†²
  28   1      }
  29          
  30          /*
  31              é‡‡ç”¨å®šæ—¶æ£€æµ‹è„‰å†²çš„æ–¹å¼æ¥æ£€æµ‹é€Ÿåº¦ï¼Œä½†æ˜¯æ¯æ®µæ—¶é—´å†…ä¼šå…ˆè®¡ç®—é€Ÿåº¦ï¼Œæœ€åå†
             -æ±‚å¹³å‡å€¼ï¼Œä¼šæœ‰1~2km/hçš„è¯¯å·®
  32          */
  33          #if 0 
              // é€Ÿåº¦æ‰«æå‡½æ•°
              void speed_scan(void)
              {
                  volatile u32 cur_speed = 0;                    // è®°å½•å½“å‰é‡‡é›†åˆ°çš„é€Ÿåº¦
                  static volatile u32 cur_speed_average_val = 0; // å­˜æ”¾å½“å‰é€Ÿåº¦çš„å¹³å‡å€¼(å•ä½ï¼škm/h)
                  static volatile u32 cur_speed_actual_scan_time_cnt = 0; // å­˜æ”¾å½“å‰ é€Ÿåº¦æ‰«ææ—¶é—´
              
                  static volatile u8 speed_scan_cnt = 0;
              
                  if (flag_is_update_speed_pulse_cnt) // å¦‚æœæœ‰æ•°æ®æ›´æ–°
                  {
                      flag_is_update_speed_pulse_cnt = 0;
                      /*
                          è®¡ç®— xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° / è½¦è½®ä¸€åœˆå
             -¯¹åº”å¤šå°‘ä¸ªè„‰å†² * ä¸€åœˆå¯¹åº” xx æ¯«ç±³
                          æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        07/11/2025 11:11:28 PAGE 2   

                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° * ä¸€åœˆå¯¹åº” 
             -xx æ¯«ç±³ / è½¦è½®ä¸€åœˆå¯¹åº”å¤šå°‘ä¸ªè„‰å†²
                      */
                      cur_speed = detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN;
              
                      // printf("cur pulse cnt %lu \n", detect_speed_pulse_cnt[1]); // ä¸´æ—¶æµ‹è¯•ç”¨
              
                      detect_speed_pulse_cnt[1] = 0; // æ¸…ç©ºè„‰å†²è®¡æ•°
                      distance += cur_speed;         // å­˜æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³
              
                      /*
                          å·²çŸ¥åœ¨æ‰«ææ—¶é—´å†…èµ°è¿‡äº†xx mm
                          æ—¶é€Ÿçš„è®¡ç®—å…¬å¼:
                          æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) * 3.6
                              æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000ï¼Œè½¬æ¢æˆ m/æ‰«ææ—¶é—´ çš„å•ä½
                              * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”)ï¼Œè½¬æ¢æˆä»¥sä¸ºå•ä½çš„é€Ÿåº¦
                              * 3.6ï¼Œå› ä¸º 1m/s == 3.6km/hï¼Œæœ€åè½¬æ¢æˆ ä»¥km/hçš„å•ä½
                          è½¬æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          æ—¶é€Ÿ == æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» * 36 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) / 10000ï¼›
              
                          é€æ¸å˜æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          cur_speed = cur_speed * 36 * (1 / (SPEED_SCAN_TIME_MS / 1000)) / 10000;
                          cur_speed = cur_speed * 36 * 1000 / SPEED_SCAN_TIME_MS / 10000;
                          cur_speed = cur_speed * 36 / SPEED_SCAN_TIME_MS / 10;
                      */
                      // cur_speed = (cur_speed * 36) / speed_actual_scan_time_cnt / 10;
              
                      // printf("cur speed %lu \n", cur_speed);
              
                      if (speed_scan_cnt < SPEED_SCAN_FILTER_CNT)
                      {
                          // å¦‚æœæœªè¾¾åˆ°é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt++;
                          cur_speed_average_val += cur_speed ; // ç´¯åŠ å½“å‰å¾—åˆ°çš„æ—¶é€Ÿ(å•ä½ï¼škm/h)
                          cur_speed_actual_scan_time_cnt += speed_actual_scan_time_cnt ; // ç´¯åŠ å½“å‰
              
                          // if (cur_speed)
                          // {
                          //     printf("ori speed %lu\n", cur_speed);
                          // }
                      }
                      else
                      {
                          // å¦‚æœè¾¾åˆ°äº†é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt = 0;
                          cur_speed_average_val = (cur_speed_average_val * 36) / cur_speed_actual_scan_time_cnt / 10 ;
                          // cur_speed_average_val /= SPEED_SCAN_FILTER_CNT; // æ—¶é€Ÿå–å¹³å‡å€¼
                          fun_info.speed = cur_speed_average_val;         // å­˜æ”¾å¾—åˆ°çš„æ—¶é€Ÿ
                          cur_speed_average_val = 0;                      // æ¸…ç©ºå˜é‡çš„å€¼
                          cur_speed_actual_scan_time_cnt = 0;
                          
              
                          // printf("cur speed %lu km/h\n", fun_info.speed);
              #if USE_MY_DEBUG
              
                          if (fun_info.speed != 0)
                          {
                              printf("cur speed %lu km/h\n", fun_info.speed);
                          }
              
              #endif
              
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        07/11/2025 11:11:28 PAGE 3   

                          // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
                          if (fun_info.speed > 999)
                          {
                              fun_info.speed = 999;
                          }
              
                          flag_get_speed = 1; //
                      }
                  }
              }
              #endif
 122          
 123          #if 0
              // é€Ÿåº¦æ‰«æå‡½æ•°
              void speed_scan(void)
              {
                  volatile u32 cur_speed_pulse_cnt = 0;                   // è®°å½•å½“å‰é‡‡é›†åˆ°çš„é€Ÿåº¦
                  static volatile u32 cur_speed_average_val = 0;          // å­˜æ”¾å½“å‰é€Ÿåº¦çš„å¹³å‡å€¼(å•ä½ï¼škm/
             -h)
                  static volatile u32 cur_speed_actual_scan_time_cnt = 0; // å­˜æ”¾å½“å‰ é€Ÿåº¦æ‰«ææ—¶é—´
              
                  static volatile u8 speed_scan_cnt = 0;
              
                  if (flag_is_update_speed_pulse_cnt) // å¦‚æœæœ‰æ•°æ®æ›´æ–°
                  {
                      flag_is_update_speed_pulse_cnt = 0;
                      /*
                          è®¡ç®— xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° / è½¦è½®ä¸€åœˆå
             -¯¹åº”å¤šå°‘ä¸ªè„‰å†² * ä¸€åœˆå¯¹åº” xx æ¯«ç±³
                          æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° * ä¸€åœˆå¯¹åº” 
             -xx æ¯«ç±³ / è½¦è½®ä¸€åœˆå¯¹åº”å¤šå°‘ä¸ªè„‰å†²
                      */
                      // cur_speed_pulse_cnt = detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER
             -_TURN;
                      cur_speed_pulse_cnt = detect_speed_pulse_cnt[1]; // å¾—åˆ°ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•°
              
                      distance += detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN; // å­˜
             -æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³
                      detect_speed_pulse_cnt[1] = 0;                                                              // æ¸…
             -ç©ºè„‰å†²è®¡æ•°
              
                      if (speed_scan_cnt < SPEED_SCAN_FILTER_CNT)
                      {
                          // å¦‚æœæœªè¾¾åˆ°é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt++;
                          cur_speed_average_val += cur_speed_pulse_cnt;                 // ç´¯åŠ å½“å‰å¾—åˆ°çš„è„‰å†²ä¸
             -ªæ•°
                          cur_speed_actual_scan_time_cnt += speed_actual_scan_time_cnt; // ç´¯åŠ å½“å‰æ‰«æé€Ÿåº¦æ‰€ç”
             -¨çš„æ—¶é—´
                      }
                      else
                      {
                          // å¦‚æœè¾¾åˆ°äº†é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt = 0;
              
                          /*
                              å·²çŸ¥åœ¨æ‰«ææ—¶é—´å†…èµ°è¿‡äº†xx mm
                              æ—¶é€Ÿçš„è®¡ç®—å…¬å¼:
                              æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) * 3.6
                                  æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000ï¼Œè½¬æ¢æˆ m/æ‰«ææ—¶é—´ çš„å•ä½
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        07/11/2025 11:11:28 PAGE 4   

                                  * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”)ï¼Œè½¬æ¢æˆä»¥sä¸ºå•ä½çš„é€Ÿåº¦
                                  * 3.6ï¼Œå› ä¸º 1m/s == 3.6km/hï¼Œæœ€åè½¬æ¢æˆ ä»¥km/hçš„å•ä½
                              è½¬æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                              æ—¶é€Ÿ == æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» * 36 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) / 10000ï¼
             -›
              
                              é€æ¸å˜æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          */
                          cur_speed_average_val = (cur_speed_average_val * 36 * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULS
             -E_PER_TURN) / 10 / cur_speed_actual_scan_time_cnt;
                          // cur_speed_average_val /= SPEED_SCAN_FILTER_CNT; // æ—¶é€Ÿå–å¹³å‡å€¼
                          fun_info.speed = cur_speed_average_val; // å­˜æ”¾å¾—åˆ°çš„æ—¶é€Ÿ
                          cur_speed_average_val = 0;              // æ¸…ç©ºå˜é‡çš„å€¼
                          cur_speed_actual_scan_time_cnt = 0;
              
                          printf("cur speed %lu km/h\n", fun_info.speed);
              #if USE_MY_DEBUG
              
                          if (fun_info.speed != 0)
                          {
                              printf("cur speed %lu km/h\n", fun_info.speed);
                          }
              
              #endif
              
                          // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
                          if (fun_info.speed > 999)
                          {
                              fun_info.speed = 999;
                          }
              
                          flag_get_speed = 1; //
                      }
                  }
              }
              #endif
 199          
 200          volatile bit flag_is_speed_scan_over_time = 0; // é€Ÿåº¦æ£€æµ‹æ˜¯å¦ä¸€ç›´æ²¡æœ‰è„‰å†²åˆ°æ¥ï¼Œå¯¼è‡´è¶…æ—
             -¶
 201          volatile u32 speed_pulse_cnt = 0;              // è®°å½•è„‰å†²ä¸ªæ•°ï¼Œåœ¨å®šæ—¶å™¨ä¸­æ–­ç´¯åŠ 
 202          volatile u32 speed_scan_time_ms = 0;           // è®°å½•æ‰«ææ—¶é—´
 203          static volatile u32 cur_speed_scan_time = 0;
 204          static volatile u32 cur_speed_scan_pulse = 0;
 205          
 206          void update_speed_scan_data(void) // æ›´æ–°æ£€æµ‹æ—¶é€Ÿçš„æ•°æ®
 207          {
 208   1          cur_speed_scan_time += speed_scan_time_ms;
 209   1          speed_scan_time_ms = 0;
 210   1          cur_speed_scan_pulse += speed_pulse_cnt;
 211   1          speed_pulse_cnt = 0;
 212   1      }
 213          
 214          void speed_scan(void)
 215          {
 216   1          volatile u32 cur_speed = 0;
 217   1          u32 tmp = 0;
 218   1      
 219   1          if (cur_speed_scan_time >= SPEED_SCAN_UPDATE_TIME || flag_is_speed_scan_over_time)
 220   1          {
 221   2              /*
 222   2                  é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•° / ä¸€åœˆå¯¹åº”çš„è„‰å†²ä¸ªæ•° * è½¦è½®ä¸€åœˆå¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå
             -•ä½ï¼šmmï¼‰ï¼Œ
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        07/11/2025 11:11:28 PAGE 5   

 223   2                  è®¡ç®—å¾—åˆ° é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰
 224   2              */
 225   2              // u32 tmp = (cur_speed_scan_pulse * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN);
 226   2              tmp = ((cur_speed_scan_pulse * SPEED_SCAN_MM_PER_TURN) / SPEED_SCAN_PULSE_PER_TURN);
 227   2              // printf("cur_speed_scan_pulse %lu\n", cur_speed_scan_pulse);
 228   2      
 229   2              if (flag_is_speed_scan_over_time) // è¶…æ—¶ï¼Œé‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•°å¯¹åº”ä¸€ç›´æ˜¯0km/hï¼Œè®¤ä¸
             -ºæ—¶é€Ÿæ˜¯0
 230   2              {
 231   3                  cur_speed = 0;
 232   3              }
 233   2              else // æœªè¶…æ—¶ï¼Œè®¡ç®—é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼Œå†è½¬æ¢æˆä»¥km/hçš„å
             -•ä½
 234   2              {
 235   3                  /*
 236   3                      é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰/ é‡‡é›†æ‰€ç”¨çš„æ—¶é—´ï¼ˆå•ä½
             -ï¼šmsï¼‰ == é€Ÿåº¦ï¼ˆå•ä½ï¼šmm/msï¼‰
 237   3                      1mm/ms == 1m/s
 238   3                      å› ä¸º 1mm/ms * 1000 == 1m/ms
 239   3                           1m/ms  / 1000 == 1m/s
 240   3                           å…ˆä¹˜ä»¥1000å†é™¤ä»¥1000ï¼Œé‚£ä¹ˆè¿™ä¸ªæ“ä½œå°±å¯ä»¥å»æ‰ï¼Œç›´æ¥åŒ–ç®€ä¸º 1mm/
             -ms == 1m/s
 241   3      
 242   3                      1m/s == 3.6km/hï¼Œé‚£ä¹ˆæ ¹æ®å¾—åˆ°çš„ ä»¥ m/s ä¸ºå•ä½çš„é€Ÿåº¦ï¼Œå…ˆä¹˜ä»¥36å†é™¤ä»¥1
             -0ï¼Œå¾—åˆ°ä»¥km/hä¸ºå•ä½çš„é€Ÿåº¦å€¼
 243   3      
 244   3                      cur_speed == é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰/ é‡‡é›†æ‰€ç”¨çš„æ
             -—¶é—´ï¼ˆå•ä½ï¼šmsï¼‰* 3.6
 245   3                      æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„æ ¼å¼ï¼š
 246   3                      cur_speed == é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰ * 36 / 10 / é‡‡é›
             -†æ‰€ç”¨çš„æ—¶é—´ï¼ˆå•ä½ï¼šmsï¼‰
 247   3                  */
 248   3                  cur_speed = tmp * 36 / 10 / cur_speed_scan_time;
 249   3              }
 250   2      
 251   2              // é˜²æ­¢æ—¶é€Ÿä¸º0æ—¶ï¼ˆæœ‰å¯èƒ½æ˜¯æ¨è½¦ï¼Œè®°å½•ä¸åˆ°é€Ÿåº¦ï¼‰ï¼Œè®°å½•ä¸åˆ°é‡Œç¨‹
 252   2              distance += tmp;
 253   2      
 254   2              // printf("cur distace 2 %lu\n", distance);
 255   2              // printf("cur distace %lu\n", distance);
 256   2              // printf("cur speed %lu km/h\n", cur_speed);
 257   2      
 258   2              cur_speed_scan_pulse = 0;
 259   2              cur_speed_scan_time = 0;
 260   2              flag_is_speed_scan_over_time = 0;
 261   2      
 262   2              fun_info.speed = cur_speed;
 263   2              // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
 264   2              if (fun_info.speed > 999)
 265   2              {
 266   3                  fun_info.speed = 999;
 267   3              }
 268   2      
 269   2              flag_get_speed = 1; // è¡¨ç¤ºé€Ÿåº¦æœ‰æ•°æ®æ›´æ–°
 270   2          } // if (cur_speed_scan_time >= 500 || flag_is_speed_scan_over_time)
 271   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    290    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16       8
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        07/11/2025 11:11:28 PAGE 6   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
