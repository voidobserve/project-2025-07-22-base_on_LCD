C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/06/2025 17:46:20 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\speed_scan.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X
                    -000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Re
                    -lease\Listings\speed_scan.lst) OBJECT(.\Release\Objects\speed_scan.obj)

line level    source

   1          #include "speed_scan.h"
   2          
   3          #if SPEED_SCAN_ENABLE
   4          
   5          #if 0
              // Ê†áÂøó‰ΩçÔºåÊòØÂê¶Áî±Êõ¥Êñ∞ËÆ°Êï∞,Áî±ÂÆöÊó∂Âô®Êù•ÁΩÆ‰Ωç
              // 0--Êú™Êõ¥Êñ∞ËÑâÂÜ≤ËÆ°Êï∞Ôºå1--ÊúâÊñ∞ÁöÑËÑâÂÜ≤ËÆ°Êï∞
              volatile bit flag_is_update_speed_pulse_cnt = 0;
              volatile u16 speed_scan_time_cnt = 0;        // ÈÄüÂ∫¶Êâ´ÊèèÊó∂ÔºåÁî®Âà∞ÁöÑÊó∂Èó¥ËÆ°Êï∞ÂÄºÔºå‰ºöÂú®ÂÆöÊó∂Â
             -ô®‰∏≠Êñ≠‰∏≠Á¥ØÂä†
              volatile u16 speed_actual_scan_time_cnt = 0; // Â≠òÊîæÂÆûÈôÖÁöÑÈÄüÂ∫¶Êâ´ÊèèÊó∂Èó¥(ÂÆûÈôÖÁöÑÈÄüÂ∫¶Êâ´ÊèèÁî®
             -Êó∂)
              // volatile u32 detect_speed_pulse_cnt = 0; // Ê£ÄÊµãÊó∂ÈÄüÁöÑËÑâÂÜ≤ËÆ°Êï∞ÂÄº(Áî®IO‰∏≠Êñ≠Êù•Ê£ÄÊµã)
              /*
                  Â≠òÊîæ Ê£ÄÊµãÂà∞ÁöÑÊó∂ÈÄüËÑâÂÜ≤ËÆ°Êï∞ÂÄºÔºå‰ºöÂú®‰∏≠Êñ≠ÂÜÖÁ¥ØÂä†
                  ‰ΩøÁî®‰∫ÜÂèåÁºìÂÜ≤Ôºå[0]Áî®Âú®ÂÆöÊó∂Âô®‰∏≠Êñ≠‰∏≠Ôºå[1]Áî®Âú®Â§ÑÁêÜÂáΩÊï∞‰∏≠
                  ÂΩì flag_is_update_speed_pulse_cnt == 1Êó∂ÔºåËØ¥ÊòéÂ∑≤ÁªèÊúâÊï∞ÊçÆÊõ¥Êñ∞
              */
              volatile u32 detect_speed_pulse_cnt[2] = {0}; // Ê£ÄÊµãÊó∂ÈÄüÁöÑËÑâÂÜ≤ËÆ°Êï∞ÂÄº
              #endif
  19          
  20          // Êó∂ÈÄüÊâ´ÊèèÁöÑÈÖçÁΩÆ
  21          void speed_scan_config(void)
  22          {
  23   1      #if 1 // ‰ΩøÁî®ÂÆöÊó∂Âô®Êâ´ÊèèIOÁîµÂπ≥ÂèòÂåñÊù•ËÆ°ÁÆóËÑâÂÜ≤
  24   1      
  25   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x3); // ËæìÂÖ•Ê®°Âºè
  26   1          P1_PU |= GPIO_P15_PULL_UP(0x1);    // ÈÖçÁΩÆ‰∏∫‰∏äÊãâ
  27   1      
  28   1      #endif // ‰ΩøÁî®ÂÆöÊó∂Âô®Êâ´ÊèèIOÁîµÂπ≥ÂèòÂåñÊù•ËÆ°ÁÆóËÑâÂÜ≤
  29   1      }
  30            
  31          static volatile u8 speed_buff[SPEED_SCAN_BUFF_SIZE] = {0};
  32          static volatile u8 cur_send_speed_buff_index = 0;
  33          volatile bit flag_is_send_speed_time_come = 0; // Ê†áÂøó‰ΩçÔºåÂèëÈÄÅÈÄüÂ∫¶ÁöÑÊó∂Èó¥Âà∞Êù•
  34          
  35          volatile bit flag_is_speed_scan_over_time = 0; // ÈÄüÂ∫¶Ê£ÄÊµãÊòØÂê¶‰∏ÄÁõ¥Ê≤°ÊúâËÑâÂÜ≤Âà∞Êù•ÔºåÂØºËá¥Ë∂ÖÊó
             -∂
  36          volatile u32 speed_pulse_cnt = 0;              // ËÆ∞ÂΩïËÑâÂÜ≤‰∏™Êï∞ÔºåÂú®ÂÆöÊó∂Âô®‰∏≠Êñ≠Á¥ØÂä†
  37          volatile u16 speed_scan_time_ms = 0;           // ËÆ∞ÂΩïÊâ´ÊèèÊó∂Èó¥
  38          static volatile u32 cur_speed_scan_time = 0;
  39          static volatile u32 cur_speed_scan_pulse = 0;
  40          
  41          void update_speed_scan_data(void) // Êõ¥Êñ∞Ê£ÄÊµãÊó∂ÈÄüÁöÑÊï∞ÊçÆ
  42          {
  43   1          cur_speed_scan_time += speed_scan_time_ms;
  44   1          speed_scan_time_ms = 0;
  45   1          cur_speed_scan_pulse += speed_pulse_cnt;
  46   1          speed_pulse_cnt = 0;
  47   1      }
  48          
  49          void speed_scan(void)
  50          {
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/06/2025 17:46:20 PAGE 2   

  51   1          volatile u16 cur_speed = 0;
  52   1          u32 tmp = 0;
  53   1      
  54   1          if (cur_speed_scan_time >= SPEED_SCAN_UPDATE_TIME || flag_is_speed_scan_over_time)
  55   1          {
  56   2              /*
  57   2                  ÈááÈõÜÂà∞ÁöÑËÑâÂÜ≤‰∏™Êï∞ / ‰∏ÄÂúàÂØπÂ∫îÁöÑËÑâÂÜ≤‰∏™Êï∞ * ËΩ¶ËΩÆ‰∏ÄÂúàÂØπÂ∫îËµ∞ËøáÁöÑË∑ùÁ¶ªÔºàÂ
             -çï‰ΩçÔºömmÔºâÔºå
  58   2                  ËÆ°ÁÆóÂæóÂà∞ ÈááÈõÜÁöÑËÑâÂÜ≤‰∏™Êï∞ÂØπÂ∫îËµ∞ËøáÁöÑË∑ùÁ¶ªÔºàÂçï‰ΩçÔºömmÔºâ
  59   2              */
  60   2              // u32 tmp = (cur_speed_scan_pulse * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN);
  61   2              tmp = (((u32)cur_speed_scan_pulse * SPEED_SCAN_MM_PER_TURN) / SPEED_SCAN_PULSE_PER_TURN);
  62   2              // printf("cur_speed_scan_pulse %lu\n", cur_speed_scan_pulse);
  63   2      
  64   2              if (flag_is_speed_scan_over_time) // Ë∂ÖÊó∂ÔºåÈááÈõÜÂà∞ÁöÑËÑâÂÜ≤‰∏™Êï∞ÂØπÂ∫î‰∏ÄÁõ¥ÊòØ0km/hÔºåËÆ§‰∏
             -∫Êó∂ÈÄüÊòØ0
  65   2              {
  66   3                  cur_speed = 0;
  67   3              }
  68   2              else // Êú™Ë∂ÖÊó∂ÔºåËÆ°ÁÆóÈááÈõÜÂà∞ÁöÑËÑâÂÜ≤‰∏™Êï∞ÂØπÂ∫îËµ∞ËøáÁöÑË∑ùÁ¶ªÔºåÂÜçËΩ¨Êç¢Êàê‰ª•km/hÁöÑÂç
             -ï‰Ωç
  69   2              {
  70   3                  /*
  71   3                      ÈááÈõÜÁöÑËÑâÂÜ≤‰∏™Êï∞ÂØπÂ∫îËµ∞ËøáÁöÑË∑ùÁ¶ªÔºàÂçï‰ΩçÔºömmÔºâ/ ÈááÈõÜÊâÄÁî®ÁöÑÊó∂Èó¥ÔºàÂçï‰Ω
             -çÔºömsÔºâ == ÈÄüÂ∫¶ÔºàÂçï‰ΩçÔºömm/msÔºâ
  72   3                      1mm/ms == 1m/s
  73   3                      Âõ†‰∏∫ 1mm/ms * 1000 == 1m/ms
  74   3                           1m/ms  / 1000 == 1m/s
  75   3                           ÂÖà‰πò‰ª•1000ÂÜçÈô§‰ª•1000ÔºåÈÇ£‰πàËøô‰∏™Êìç‰ΩúÂ∞±ÂèØ‰ª•ÂéªÊéâÔºåÁõ¥Êé•ÂåñÁÆÄ‰∏∫ 1mm/
             -ms == 1m/s
  76   3      
  77   3                      1m/s == 3.6km/hÔºåÈÇ£‰πàÊ†πÊçÆÂæóÂà∞ÁöÑ ‰ª• m/s ‰∏∫Âçï‰ΩçÁöÑÈÄüÂ∫¶ÔºåÂÖà‰πò‰ª•36ÂÜçÈô§‰ª•1
             -0ÔºåÂæóÂà∞‰ª•km/h‰∏∫Âçï‰ΩçÁöÑÈÄüÂ∫¶ÂÄº
  78   3      
  79   3                      cur_speed == ÈááÈõÜÁöÑËÑâÂÜ≤‰∏™Êï∞ÂØπÂ∫îËµ∞ËøáÁöÑË∑ùÁ¶ªÔºàÂçï‰ΩçÔºömmÔºâ/ ÈááÈõÜÊâÄÁî®ÁöÑÊ
             -ó∂Èó¥ÔºàÂçï‰ΩçÔºömsÔºâ* 3.6
  80   3                      Êç¢ÊàêÂçïÁâáÊú∫ÂèØ‰ª•ËÆ°ÁÆóÁöÑÊ†ºÂºèÔºö
  81   3                      cur_speed == ÈááÈõÜÁöÑËÑâÂÜ≤‰∏™Êï∞ÂØπÂ∫îËµ∞ËøáÁöÑË∑ùÁ¶ªÔºàÂçï‰ΩçÔºömmÔºâ * 36 / 10 / ÈááÈõ
             -ÜÊâÄÁî®ÁöÑÊó∂Èó¥ÔºàÂçï‰ΩçÔºömsÔºâ
  82   3                  */
  83   3                  cur_speed = (u32)tmp * 36 / 10 / cur_speed_scan_time;
  84   3              }
  85   2      
  86   2              // Èò≤Ê≠¢Êó∂ÈÄü‰∏∫0Êó∂ÔºàÊúâÂèØËÉΩÊòØÊé®ËΩ¶ÔºåËÆ∞ÂΩï‰∏çÂà∞ÈÄüÂ∫¶ÔºâÔºåËÆ∞ÂΩï‰∏çÂà∞ÈáåÁ®ã
  87   2              distance += tmp;
  88   2      
  89   2              // printf("cur distace 2 %lu\n", distance);
  90   2              // printf("cur distace %lu\n", distance);
  91   2              // printf("cur speed %lu km/h\n", cur_speed);
  92   2      
  93   2              cur_speed_scan_pulse = 0;
  94   2              cur_speed_scan_time = 0;
  95   2              flag_is_speed_scan_over_time = 0;
  96   2      
  97   2              // ÈôêÂà∂Ë¶ÅÂèëÈÄÅÁöÑÊó∂ÈÄü:
  98   2              if (cur_speed > 999) // 999 km/h
  99   2              {
 100   3                  cur_speed = 999;
 101   3              }
 102   2      
 103   2      #if 0
                      /*
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/06/2025 17:46:20 PAGE 3   

                          Êâ´ÊèèÂÆåÊó∂ÈÄüÂ∞±ÂèëÈÄÅÁöÑÁ®ãÂ∫èÔºåÂú®ÊòæÁ§∫ÈÉ®ÂàÜ‰ºöÊúâÂç°È°øÔºå
                          ÊòæÁ§∫ÂÅö‰∏ç‰∫ÜÂä®ÁîªÔºåÂè™ËÉΩÂçïÁâáÊú∫Êù•Ë∞ÉËäÇ
                      */
                      fun_info.speed = cur_speed;
                      // ÈôêÂà∂Ë¶ÅÂèëÈÄÅÁöÑÊó∂ÈÄü:
                      if (fun_info.speed > 999)
                      {
                          fun_info.speed = 999;
                      }
              
                      flag_get_speed = 1; // Ë°®Á§∫ÈÄüÂ∫¶ÊúâÊï∞ÊçÆÊõ¥Êñ∞
              #endif
 117   2      
 118   2              speed_buff_update(cur_speed);
 119   2      
 120   2          } // if (cur_speed_scan_time >= 500 || flag_is_speed_scan_over_time)
 121   1      }
 122          
 123          void speed_buff_update(u16 speed)
 124          {
 125   1          static u16 last_speed = 0;    // Â≠òÊîæ‰∏ä‰∏ÄÊ¨°ÈááÈõÜÂà∞ÁöÑÈÄüÂ∫¶
 126   1          u16 speed_difference = 0;     // Â≠òÊîæÈÄüÂ∫¶ÁöÑÂ∑ÆÂÄº
 127   1          bit dir_of_speed_change = 0; // ÈÄüÂ∫¶ÂèòÂåñÁöÑÊñπÂêëÔºå0--ÈÄüÂ∫¶ÂèòÂ∞èÔºå1--ÈÄüÂ∫¶ÂèòÂ§ß
 128   1          u8 i = 0;                    // Âæ™ÁéØËÆ°Êï∞ÂÄº
 129   1      
 130   1          if (speed > last_speed)
 131   1          {
 132   2              // Â¶ÇÊûúÂΩìÂâçÁöÑÈÄüÂ∫¶ Â§ß‰∫é ‰∏ä‰∏ÄÊ¨°ÈááÈõÜÂà∞ÁöÑÈÄüÂ∫¶
 133   2              speed_difference = speed - last_speed;
 134   2              dir_of_speed_change = 1; // Ë°®Á§∫ÈÄüÂ∫¶ÂèòÂ§ß
 135   2          }
 136   1          else if (speed < last_speed)
 137   1          {
 138   2              // Â¶ÇÊûúÂΩìÂâçÁöÑÈÄüÂ∫¶ Â∞è‰∫é ‰∏ä‰∏ÄÊ¨°ÈááÈõÜÂà∞ÁöÑÈÄüÂ∫¶
 139   2              speed_difference = last_speed - speed;
 140   2              dir_of_speed_change = 0; // Ë°®Á§∫ÈÄüÂ∫¶ÂèòÂ∞è
 141   2          }
 142   1          else
 143   1          {
 144   2              for (i = 0; i < SPEED_SCAN_BUFF_SIZE; i++)
 145   2              {
 146   3                  speed_buff[i] = speed;
 147   3              }
 148   2      
 149   2              // // Ê≤°ÊúâÂ∑ÆÂÄºÔºåÁõ¥Êé•Êõ¥Êñ∞Ôºà‰øÆÂ§çÊ≤°ÊúâÂ∑ÆÂÄº‰∏îÊï∞ÂÄº‰∏∫0Êó∂ÔºåÊ≤°ÊúâÂèëÈÄÅÊï∞ÊçÆÁöÑÈóÆÈ
             -¢òÔºâ
 150   2              // fun_info.speed = speed;
 151   2              // flag_get_engine_speed = 1;
 152   2      
 153   2              cur_send_speed_buff_index = 0; // Ê∏∏Ê†áÂ§ç‰Ωç
 154   2              return;
 155   2          }
 156   1      
 157   1          if (dir_of_speed_change)
 158   1          {
 159   2              // Â¶ÇÊûúÈÄüÂ∫¶Âú®ÂèòÂ§ßÔºåÊï∞ÁªÑ‰ªé [0] ~ [SPEED_SCAN_BUFF_SIZE - 1] Êï∞ÂÄºË∂äÊù•Ë∂äÂ§ß
 160   2              for (i = 0; i < SPEED_SCAN_BUFF_SIZE; i++)
 161   2              {
 162   3                  speed_buff[i] = speed_difference * (i + 1) / SPEED_SCAN_BUFF_SIZE + last_speed;
 163   3              }
 164   2          }
 165   1          else
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/06/2025 17:46:20 PAGE 4   

 166   1          {
 167   2              // Â¶ÇÊûúÈÄüÂ∫¶Âú®ÂèòÂ∞èÔºåÊï∞ÁªÑ‰ªé [0] ~ [SPEED_SCAN_BUFF_SIZE - 1] Êï∞ÂÄºË∂äÊù•Ë∂äÂ∞è
 168   2              for (i = 0; i < SPEED_SCAN_BUFF_SIZE; i++)
 169   2              {
 170   3                  speed_buff[SPEED_SCAN_BUFF_SIZE - 1 - i] = last_speed - (u32)speed_difference * (SPEED_SCAN_BU
             -FF_SIZE - i - 1) / SPEED_SCAN_BUFF_SIZE;
 171   3              }
 172   2          }
 173   1      
 174   1          last_speed = speed;
 175   1          cur_send_speed_buff_index = 0; // Ê∏∏Ê†áÂ§ç‰Ωç
 176   1      }
 177          
 178          void speed_send_data(void)
 179          {
 180   1          if (flag_is_send_speed_time_come) // Â¶ÇÊûúÂèëÈÄÅÈÄüÂ∫¶ÁöÑÊó∂Èó¥Âà∞Êù•
 181   1          {
 182   2              flag_is_send_speed_time_come = 0;
 183   2      
 184   2              if (cur_send_speed_buff_index >= SPEED_SCAN_BUFF_SIZE)
 185   2              {
 186   3                  // Èò≤Ê≠¢Ë∂äÁïå
 187   3                  return;
 188   3              }
 189   2      
 190   2              fun_info.speed = speed_buff[cur_send_speed_buff_index];
 191   2              cur_send_speed_buff_index++;
 192   2      
 193   2              // printf("fun_info.speed = %lu\n", fun_info.speed);
 194   2              flag_get_speed = 1;
 195   2          }
 196   1      }
 197          
 198          #endif // SPEED_SCAN_ENABLE


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    626    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     24      11
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
