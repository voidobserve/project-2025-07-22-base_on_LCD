C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/01/2025 15:47:47 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\speed_scan.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X
                    -000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Re
                    -lease\Listings\speed_scan.lst) OBJECT(.\Release\Objects\speed_scan.obj)

line level    source

   1          #include "speed_scan.h"
   2          
   3          #if 0
              // æ ‡å¿—ä½ï¼Œæ˜¯å¦ç”±æ›´æ–°è®¡æ•°,ç”±å®šæ—¶å™¨æ¥ç½®ä½
              // 0--æœªæ›´æ–°è„‰å†²è®¡æ•°ï¼Œ1--æœ‰æ–°çš„è„‰å†²è®¡æ•°
              volatile bit flag_is_update_speed_pulse_cnt = 0;
              volatile u16 speed_scan_time_cnt = 0;        // é€Ÿåº¦æ‰«ææ—¶ï¼Œç”¨åˆ°çš„æ—¶é—´è®¡æ•°å€¼ï¼Œä¼šåœ¨å®šæ—¶å
             -™¨ä¸­æ–­ä¸­ç´¯åŠ 
              volatile u16 speed_actual_scan_time_cnt = 0; // å­˜æ”¾å®é™…çš„é€Ÿåº¦æ‰«ææ—¶é—´(å®é™…çš„é€Ÿåº¦æ‰«æç”¨
             -æ—¶)
              // volatile u32 detect_speed_pulse_cnt = 0; // æ£€æµ‹æ—¶é€Ÿçš„è„‰å†²è®¡æ•°å€¼(ç”¨IOä¸­æ–­æ¥æ£€æµ‹)
              /*
                  å­˜æ”¾ æ£€æµ‹åˆ°çš„æ—¶é€Ÿè„‰å†²è®¡æ•°å€¼ï¼Œä¼šåœ¨ä¸­æ–­å†…ç´¯åŠ 
                  ä½¿ç”¨äº†åŒç¼“å†²ï¼Œ[0]ç”¨åœ¨å®šæ—¶å™¨ä¸­æ–­ä¸­ï¼Œ[1]ç”¨åœ¨å¤„ç†å‡½æ•°ä¸­
                  å½“ flag_is_update_speed_pulse_cnt == 1æ—¶ï¼Œè¯´æ˜å·²ç»æœ‰æ•°æ®æ›´æ–°
              */
              volatile u32 detect_speed_pulse_cnt[2] = {0}; // æ£€æµ‹æ—¶é€Ÿçš„è„‰å†²è®¡æ•°å€¼
              #endif
  17          
  18          // æ—¶é€Ÿæ‰«æçš„é…ç½®
  19          void speed_scan_config(void)
  20          {
  21   1      #if 1 // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³å˜åŒ–æ¥è®¡ç®—è„‰å†²
  22   1      
  23   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x3); // è¾“å…¥æ¨¡å¼
  24   1          P1_PU |= GPIO_P15_PULL_UP(0x1);    // é…ç½®ä¸ºä¸Šæ‹‰
  25   1      
  26   1      #endif // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³å˜åŒ–æ¥è®¡ç®—è„‰å†²
  27   1      }
  28          
  29          /*
  30              é‡‡ç”¨å®šæ—¶æ£€æµ‹è„‰å†²çš„æ–¹å¼æ¥æ£€æµ‹é€Ÿåº¦ï¼Œä½†æ˜¯æ¯æ®µæ—¶é—´å†…ä¼šå…ˆè®¡ç®—é€Ÿåº¦ï¼Œæœ€åå†
             -æ±‚å¹³å‡å€¼ï¼Œä¼šæœ‰1~2km/hçš„è¯¯å·®
  31          */
  32          #if 0 
              // é€Ÿåº¦æ‰«æå‡½æ•°
              void speed_scan(void)
              {
                  volatile u32 cur_speed = 0;                    // è®°å½•å½“å‰é‡‡é›†åˆ°çš„é€Ÿåº¦
                  static volatile u32 cur_speed_average_val = 0; // å­˜æ”¾å½“å‰é€Ÿåº¦çš„å¹³å‡å€¼(å•ä½ï¼škm/h)
                  static volatile u32 cur_speed_actual_scan_time_cnt = 0; // å­˜æ”¾å½“å‰ é€Ÿåº¦æ‰«ææ—¶é—´
              
                  static volatile u8 speed_scan_cnt = 0;
              
                  if (flag_is_update_speed_pulse_cnt) // å¦‚æœæœ‰æ•°æ®æ›´æ–°
                  {
                      flag_is_update_speed_pulse_cnt = 0;
                      /*
                          è®¡ç®— xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° / è½¦è½®ä¸€åœˆå
             -¯¹åº”å¤šå°‘ä¸ªè„‰å†² * ä¸€åœˆå¯¹åº” xx æ¯«ç±³
                          æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° * ä¸€åœˆå¯¹åº” 
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/01/2025 15:47:47 PAGE 2   

             -xx æ¯«ç±³ / è½¦è½®ä¸€åœˆå¯¹åº”å¤šå°‘ä¸ªè„‰å†²
                      */
                      cur_speed = detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN;
              
                      // printf("cur pulse cnt %lu \n", detect_speed_pulse_cnt[1]); // ä¸´æ—¶æµ‹è¯•ç”¨
              
                      detect_speed_pulse_cnt[1] = 0; // æ¸…ç©ºè„‰å†²è®¡æ•°
                      distance += cur_speed;         // å­˜æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³
              
                      /*
                          å·²çŸ¥åœ¨æ‰«ææ—¶é—´å†…èµ°è¿‡äº†xx mm
                          æ—¶é€Ÿçš„è®¡ç®—å…¬å¼:
                          æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) * 3.6
                              æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000ï¼Œè½¬æ¢æˆ m/æ‰«ææ—¶é—´ çš„å•ä½
                              * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”)ï¼Œè½¬æ¢æˆä»¥sä¸ºå•ä½çš„é€Ÿåº¦
                              * 3.6ï¼Œå› ä¸º 1m/s == 3.6km/hï¼Œæœ€åè½¬æ¢æˆ ä»¥km/hçš„å•ä½
                          è½¬æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          æ—¶é€Ÿ == æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» * 36 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) / 10000ï¼›
              
                          é€æ¸å˜æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          cur_speed = cur_speed * 36 * (1 / (SPEED_SCAN_TIME_MS / 1000)) / 10000;
                          cur_speed = cur_speed * 36 * 1000 / SPEED_SCAN_TIME_MS / 10000;
                          cur_speed = cur_speed * 36 / SPEED_SCAN_TIME_MS / 10;
                      */
                      // cur_speed = (cur_speed * 36) / speed_actual_scan_time_cnt / 10;
              
                      // printf("cur speed %lu \n", cur_speed);
              
                      if (speed_scan_cnt < SPEED_SCAN_FILTER_CNT)
                      {
                          // å¦‚æœæœªè¾¾åˆ°é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt++;
                          cur_speed_average_val += cur_speed ; // ç´¯åŠ å½“å‰å¾—åˆ°çš„æ—¶é€Ÿ(å•ä½ï¼škm/h)
                          cur_speed_actual_scan_time_cnt += speed_actual_scan_time_cnt ; // ç´¯åŠ å½“å‰
              
                          // if (cur_speed)
                          // {
                          //     printf("ori speed %lu\n", cur_speed);
                          // }
                      }
                      else
                      {
                          // å¦‚æœè¾¾åˆ°äº†é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt = 0;
                          cur_speed_average_val = (cur_speed_average_val * 36) / cur_speed_actual_scan_time_cnt / 10 ;
                          // cur_speed_average_val /= SPEED_SCAN_FILTER_CNT; // æ—¶é€Ÿå–å¹³å‡å€¼
                          fun_info.speed = cur_speed_average_val;         // å­˜æ”¾å¾—åˆ°çš„æ—¶é€Ÿ
                          cur_speed_average_val = 0;                      // æ¸…ç©ºå˜é‡çš„å€¼
                          cur_speed_actual_scan_time_cnt = 0;
                          
              
                          // printf("cur speed %lu km/h\n", fun_info.speed);
              #if USE_MY_DEBUG
              
                          if (fun_info.speed != 0)
                          {
                              printf("cur speed %lu km/h\n", fun_info.speed);
                          }
              
              #endif
              
                          // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/01/2025 15:47:47 PAGE 3   

                          if (fun_info.speed > 999)
                          {
                              fun_info.speed = 999;
                          }
              
                          flag_get_speed = 1; //
                      }
                  }
              }
              #endif
 121          
 122          #if 0
              // é€Ÿåº¦æ‰«æå‡½æ•°
              void speed_scan(void)
              {
                  volatile u32 cur_speed_pulse_cnt = 0;                   // è®°å½•å½“å‰é‡‡é›†åˆ°çš„é€Ÿåº¦
                  static volatile u32 cur_speed_average_val = 0;          // å­˜æ”¾å½“å‰é€Ÿåº¦çš„å¹³å‡å€¼(å•ä½ï¼škm/
             -h)
                  static volatile u32 cur_speed_actual_scan_time_cnt = 0; // å­˜æ”¾å½“å‰ é€Ÿåº¦æ‰«ææ—¶é—´
              
                  static volatile u8 speed_scan_cnt = 0;
              
                  if (flag_is_update_speed_pulse_cnt) // å¦‚æœæœ‰æ•°æ®æ›´æ–°
                  {
                      flag_is_update_speed_pulse_cnt = 0;
                      /*
                          è®¡ç®— xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° / è½¦è½®ä¸€åœˆå
             -¯¹åº”å¤šå°‘ä¸ªè„‰å†² * ä¸€åœˆå¯¹åº” xx æ¯«ç±³
                          æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° * ä¸€åœˆå¯¹åº” 
             -xx æ¯«ç±³ / è½¦è½®ä¸€åœˆå¯¹åº”å¤šå°‘ä¸ªè„‰å†²
                      */
                      // cur_speed_pulse_cnt = detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER
             -_TURN;
                      cur_speed_pulse_cnt = detect_speed_pulse_cnt[1]; // å¾—åˆ°ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•°
              
                      distance += detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN; // å­˜
             -æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³
                      detect_speed_pulse_cnt[1] = 0;                                                              // æ¸…
             -ç©ºè„‰å†²è®¡æ•°
              
                      if (speed_scan_cnt < SPEED_SCAN_FILTER_CNT)
                      {
                          // å¦‚æœæœªè¾¾åˆ°é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt++;
                          cur_speed_average_val += cur_speed_pulse_cnt;                 // ç´¯åŠ å½“å‰å¾—åˆ°çš„è„‰å†²ä¸
             -ªæ•°
                          cur_speed_actual_scan_time_cnt += speed_actual_scan_time_cnt; // ç´¯åŠ å½“å‰æ‰«æé€Ÿåº¦æ‰€ç”
             -¨çš„æ—¶é—´
                      }
                      else
                      {
                          // å¦‚æœè¾¾åˆ°äº†é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt = 0;
              
                          /*
                              å·²çŸ¥åœ¨æ‰«ææ—¶é—´å†…èµ°è¿‡äº†xx mm
                              æ—¶é€Ÿçš„è®¡ç®—å…¬å¼:
                              æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) * 3.6
                                  æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000ï¼Œè½¬æ¢æˆ m/æ‰«ææ—¶é—´ çš„å•ä½
                                  * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”)ï¼Œè½¬æ¢æˆä»¥sä¸ºå•ä½çš„é€Ÿåº¦
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/01/2025 15:47:47 PAGE 4   

                                  * 3.6ï¼Œå› ä¸º 1m/s == 3.6km/hï¼Œæœ€åè½¬æ¢æˆ ä»¥km/hçš„å•ä½
                              è½¬æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                              æ—¶é€Ÿ == æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» * 36 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) / 10000ï¼
             -›
              
                              é€æ¸å˜æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          */
                          cur_speed_average_val = (cur_speed_average_val * 36 * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULS
             -E_PER_TURN) / 10 / cur_speed_actual_scan_time_cnt;
                          // cur_speed_average_val /= SPEED_SCAN_FILTER_CNT; // æ—¶é€Ÿå–å¹³å‡å€¼
                          fun_info.speed = cur_speed_average_val; // å­˜æ”¾å¾—åˆ°çš„æ—¶é€Ÿ
                          cur_speed_average_val = 0;              // æ¸…ç©ºå˜é‡çš„å€¼
                          cur_speed_actual_scan_time_cnt = 0;
              
                          printf("cur speed %lu km/h\n", fun_info.speed);
              #if USE_MY_DEBUG
              
                          if (fun_info.speed != 0)
                          {
                              printf("cur speed %lu km/h\n", fun_info.speed);
                          }
              
              #endif
              
                          // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
                          if (fun_info.speed > 999)
                          {
                              fun_info.speed = 999;
                          }
              
                          flag_get_speed = 1; //
                      }
                  }
              }
              #endif
 198          
 199          static volatile u8 speed_buff[SPEED_SCAN_BUFF_SIZE] = {0};
 200          static volatile u8 cur_send_speed_buff_index = 0;
 201          volatile bit flag_is_send_speed_time_come = 0; // æ ‡å¿—ä½ï¼Œå‘é€é€Ÿåº¦çš„æ—¶é—´åˆ°æ¥
 202          
 203          volatile bit flag_is_speed_scan_over_time = 0; // é€Ÿåº¦æ£€æµ‹æ˜¯å¦ä¸€ç›´æ²¡æœ‰è„‰å†²åˆ°æ¥ï¼Œå¯¼è‡´è¶…æ—
             -¶
 204          volatile u32 speed_pulse_cnt = 0;              // è®°å½•è„‰å†²ä¸ªæ•°ï¼Œåœ¨å®šæ—¶å™¨ä¸­æ–­ç´¯åŠ 
 205          volatile u32 speed_scan_time_ms = 0;           // è®°å½•æ‰«ææ—¶é—´
 206          static volatile u32 cur_speed_scan_time = 0;
 207          static volatile u32 cur_speed_scan_pulse = 0;
 208          
 209          void update_speed_scan_data(void) // æ›´æ–°æ£€æµ‹æ—¶é€Ÿçš„æ•°æ®
 210          {
 211   1          cur_speed_scan_time += speed_scan_time_ms;
 212   1          speed_scan_time_ms = 0;
 213   1          cur_speed_scan_pulse += speed_pulse_cnt;
 214   1          speed_pulse_cnt = 0;
 215   1      }
 216          
 217          void speed_scan(void)
 218          {
 219   1          volatile u16 cur_speed = 0;
 220   1          u32 tmp = 0;
 221   1      
 222   1          if (cur_speed_scan_time >= SPEED_SCAN_UPDATE_TIME || flag_is_speed_scan_over_time)
 223   1          {
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/01/2025 15:47:47 PAGE 5   

 224   2              /*
 225   2                  é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•° / ä¸€åœˆå¯¹åº”çš„è„‰å†²ä¸ªæ•° * è½¦è½®ä¸€åœˆå¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå
             -•ä½ï¼šmmï¼‰ï¼Œ
 226   2                  è®¡ç®—å¾—åˆ° é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰
 227   2              */
 228   2              // u32 tmp = (cur_speed_scan_pulse * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN);
 229   2              tmp = (((u32)cur_speed_scan_pulse * SPEED_SCAN_MM_PER_TURN) / SPEED_SCAN_PULSE_PER_TURN);
 230   2              // printf("cur_speed_scan_pulse %lu\n", cur_speed_scan_pulse);
 231   2      
 232   2              if (flag_is_speed_scan_over_time) // è¶…æ—¶ï¼Œé‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•°å¯¹åº”ä¸€ç›´æ˜¯0km/hï¼Œè®¤ä¸
             -ºæ—¶é€Ÿæ˜¯0
 233   2              {
 234   3                  cur_speed = 0;
 235   3              }
 236   2              else // æœªè¶…æ—¶ï¼Œè®¡ç®—é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼Œå†è½¬æ¢æˆä»¥km/hçš„å
             -•ä½
 237   2              {
 238   3                  /*
 239   3                      é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰/ é‡‡é›†æ‰€ç”¨çš„æ—¶é—´ï¼ˆå•ä½
             -ï¼šmsï¼‰ == é€Ÿåº¦ï¼ˆå•ä½ï¼šmm/msï¼‰
 240   3                      1mm/ms == 1m/s
 241   3                      å› ä¸º 1mm/ms * 1000 == 1m/ms
 242   3                           1m/ms  / 1000 == 1m/s
 243   3                           å…ˆä¹˜ä»¥1000å†é™¤ä»¥1000ï¼Œé‚£ä¹ˆè¿™ä¸ªæ“ä½œå°±å¯ä»¥å»æ‰ï¼Œç›´æ¥åŒ–ç®€ä¸º 1mm/
             -ms == 1m/s
 244   3      
 245   3                      1m/s == 3.6km/hï¼Œé‚£ä¹ˆæ ¹æ®å¾—åˆ°çš„ ä»¥ m/s ä¸ºå•ä½çš„é€Ÿåº¦ï¼Œå…ˆä¹˜ä»¥36å†é™¤ä»¥1
             -0ï¼Œå¾—åˆ°ä»¥km/hä¸ºå•ä½çš„é€Ÿåº¦å€¼
 246   3      
 247   3                      cur_speed == é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰/ é‡‡é›†æ‰€ç”¨çš„æ
             -—¶é—´ï¼ˆå•ä½ï¼šmsï¼‰* 3.6
 248   3                      æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„æ ¼å¼ï¼š
 249   3                      cur_speed == é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰ * 36 / 10 / é‡‡é›
             -†æ‰€ç”¨çš„æ—¶é—´ï¼ˆå•ä½ï¼šmsï¼‰
 250   3                  */
 251   3                  cur_speed = (u32)tmp * 36 / 10 / cur_speed_scan_time;
 252   3              }
 253   2      
 254   2              // é˜²æ­¢æ—¶é€Ÿä¸º0æ—¶ï¼ˆæœ‰å¯èƒ½æ˜¯æ¨è½¦ï¼Œè®°å½•ä¸åˆ°é€Ÿåº¦ï¼‰ï¼Œè®°å½•ä¸åˆ°é‡Œç¨‹
 255   2              distance += tmp;
 256   2      
 257   2              // printf("cur distace 2 %lu\n", distance);
 258   2              // printf("cur distace %lu\n", distance);
 259   2              // printf("cur speed %lu km/h\n", cur_speed);
 260   2      
 261   2              cur_speed_scan_pulse = 0;
 262   2              cur_speed_scan_time = 0;
 263   2              flag_is_speed_scan_over_time = 0;
 264   2      
 265   2              // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
 266   2              if (cur_speed > 999) // 999 km/h
 267   2              {
 268   3                  cur_speed = 999;
 269   3              }
 270   2      
 271   2      #if 0
                      /*
                          æ‰«æå®Œæ—¶é€Ÿå°±å‘é€çš„ç¨‹åºï¼Œåœ¨æ˜¾ç¤ºéƒ¨åˆ†ä¼šæœ‰å¡é¡¿ï¼Œ
                          æ˜¾ç¤ºåšä¸äº†åŠ¨ç”»ï¼Œåªèƒ½å•ç‰‡æœºæ¥è°ƒèŠ‚
                      */
                      fun_info.speed = cur_speed;
                      // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/01/2025 15:47:47 PAGE 6   

                      if (fun_info.speed > 999)
                      {
                          fun_info.speed = 999;
                      }
              
                      flag_get_speed = 1; // è¡¨ç¤ºé€Ÿåº¦æœ‰æ•°æ®æ›´æ–°
              #endif
 285   2      
 286   2              speed_buff_update(cur_speed);
 287   2      
 288   2          } // if (cur_speed_scan_time >= 500 || flag_is_speed_scan_over_time)
 289   1      }
 290          
 291          
 292          void speed_buff_update(u8 speed)
 293          {
 294   1          static u8 last_speed = 0;    // å­˜æ”¾ä¸Šä¸€æ¬¡é‡‡é›†åˆ°çš„é€Ÿåº¦
 295   1          u8 speed_difference = 0;     // å­˜æ”¾é€Ÿåº¦çš„å·®å€¼
 296   1          bit dir_of_speed_change = 0; // é€Ÿåº¦å˜åŒ–çš„æ–¹å‘ï¼Œ0--é€Ÿåº¦å˜å°ï¼Œ1--é€Ÿåº¦å˜å¤§
 297   1          u8 i = 0;                    // å¾ªç¯è®¡æ•°å€¼
 298   1      
 299   1          if (speed > last_speed)
 300   1          {
 301   2              // å¦‚æœå½“å‰çš„é€Ÿåº¦ å¤§äº ä¸Šä¸€æ¬¡é‡‡é›†åˆ°çš„é€Ÿåº¦
 302   2              speed_difference = speed - last_speed;
 303   2              dir_of_speed_change = 1; // è¡¨ç¤ºé€Ÿåº¦å˜å¤§
 304   2          }
 305   1          else if (speed < last_speed)
 306   1          {
 307   2              // å¦‚æœå½“å‰çš„é€Ÿåº¦ å°äº ä¸Šä¸€æ¬¡é‡‡é›†åˆ°çš„é€Ÿåº¦
 308   2              speed_difference = last_speed - speed;
 309   2              dir_of_speed_change = 0; // è¡¨ç¤ºé€Ÿåº¦å˜å°
 310   2          }
 311   1          else
 312   1          {
 313   2              for (i = 0; i < SPEED_SCAN_BUFF_SIZE; i++)
 314   2              {
 315   3                  speed_buff[i] = speed;
 316   3              }
 317   2              return;
 318   2          }
 319   1      
 320   1          if (dir_of_speed_change)
 321   1          {
 322   2              // å¦‚æœé€Ÿåº¦åœ¨å˜å¤§ï¼Œæ•°ç»„ä» [0] ~ [SPEED_SCAN_BUFF_SIZE - 1] æ•°å€¼è¶Šæ¥è¶Šå¤§
 323   2              for (i = 0; i < SPEED_SCAN_BUFF_SIZE; i++)
 324   2              {
 325   3                  speed_buff[i] = speed_difference * (i + 1) / SPEED_SCAN_BUFF_SIZE + last_speed;
 326   3              }
 327   2          }
 328   1          else
 329   1          {
 330   2              // å¦‚æœé€Ÿåº¦åœ¨å˜å°ï¼Œæ•°ç»„ä» [0] ~ [SPEED_SCAN_BUFF_SIZE - 1] æ•°å€¼è¶Šæ¥è¶Šå°
 331   2              for (i = 0; i < SPEED_SCAN_BUFF_SIZE; i++)
 332   2              {
 333   3                  speed_buff[SPEED_SCAN_BUFF_SIZE - 1 - i] = last_speed - (u32)speed_difference * (SPEED_SCAN_BU
             -FF_SIZE - i - 1) / SPEED_SCAN_BUFF_SIZE;
 334   3              }
 335   2          }
 336   1      
 337   1          last_speed = speed;
 338   1          cur_send_speed_buff_index = 0; // æ¸¸æ ‡å¤ä½
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        08/01/2025 15:47:47 PAGE 7   

 339   1      }
 340          
 341          void speed_send_data(void)
 342          {
 343   1          if (flag_is_send_speed_time_come) // å¦‚æœå‘é€é€Ÿåº¦çš„æ—¶é—´åˆ°æ¥
 344   1          {
 345   2              flag_is_send_speed_time_come = 0;
 346   2      
 347   2              if (cur_send_speed_buff_index >= SPEED_SCAN_BUFF_SIZE)
 348   2              {
 349   3                  // é˜²æ­¢è¶Šç•Œ
 350   3                  return;
 351   3              }
 352   2      
 353   2              fun_info.speed = speed_buff[cur_send_speed_buff_index];
 354   2              cur_send_speed_buff_index++;
 355   2      
 356   2              flag_get_speed = 1;
 357   2          }
 358   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    578    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     25       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
