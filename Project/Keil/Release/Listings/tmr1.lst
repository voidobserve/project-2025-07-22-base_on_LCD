C51 COMPILER V9.60.7.0   TMR1                                                              08/07/2025 17:46:19 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TMR1
OBJECT MODULE PLACED IN .\Release\Objects\tmr1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\tmr1.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X00
                    -0C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Rele
                    -ase\Listings\tmr1.lst) OBJECT(.\Release\Objects\tmr1.obj)

line level    source

   1          #include "tmr1.h"
   2          
   3          // #define TMR1_CNT_TIME 152 // 152 * 0.65625us 约等于100us
   4          
   5          // 定时器定时周期 (单位:Hz)
   6          // 周期值 = 系统时钟 / 定时器分频 / 频率 - 1
   7          #define TMR1_PERIOD (SYSCLK / 128 / 1000 - 1) // 1000Hz,1ms
   8          
   9          // volatile bit tmr1_flag = 0; // TMR1中断服务函数中会置位的标志位
  10          // volatile u32 tmr1_cnt = 0; // 定时器TMR1的计数值（每次在中断服务函数中会加一）
  11          
  12          /**
  13           * @brief 配置定时器TMR1，配置完成后，定时器默认关闭
  14           */
  15          void tmr1_config(void)
  16          {
  17   1          __SetIRQnIP(TMR1_IRQn, TMR1_IQn_CFG); // 设置中断优先级（TMR1）
  18   1          __DisableIRQ(TMR1_IRQn);              // 禁用中断
  19   1          IE_EA = 1;                            // 打开总中断
  20   1      
  21   1          TMR_ALLCON = TMR1_CNT_CLR(0x1); // 清除计数值
  22   1      
  23   1          TMR1_CONL &= ~TMR_PRESCALE_SEL(0x07); // 清除TMR1的预分频配置寄存器
  24   1          TMR1_CONL |= TMR_PRESCALE_SEL(0x07);  // 定时器预分频
  25   1          TMR1_CONL &= ~TMR_MODE_SEL(0x03);     // 清除TMR1的模式配置寄存器
  26   1          TMR1_CONL |= TMR_MODE_SEL(0x01);      // 配置TMR1的模式为计数器模式，最后对系统时钟
             -的脉冲进行计数
  27   1      
  28   1          TMR1_CONH &= ~TMR_PRD_PND(0x01); // 清除TMR1的计数标志位，表示未完成计数
  29   1          TMR1_CONH |= TMR_PRD_IRQ_EN(1);  // 使能TMR1的计数中断
  30   1      
  31   1          // 配置TMR1的计数周期
  32   1          TMR1_PRH = TMR_PERIOD_VAL_H((TMR1_PERIOD >> 8) & 0xFF); // 周期值
  33   1          TMR1_PRL = TMR_PERIOD_VAL_L((TMR1_PERIOD >> 0) & 0xFF);
  34   1      
  35   1          // TMR1_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除TMR1的时钟源配置寄存器
  36   1          // TMR1_CONL |= TMR_SOURCE_SEL(0x05);    // 配置TMR1的时钟源，不用任何时钟
  37   1      
  38   1          // 重新给TMR1配置时钟
  39   1          TMR1_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
  40   1          TMR1_CONL |= TMR_SOURCE_SEL(0x06);    // 配置定时器的时钟源，使用系统时钟
  41   1      
  42   1          __EnableIRQ(TMR1_IRQn); // 使能中断
  43   1          // IE_EA = 1;              // 打开总中断
  44   1      }
  45          
  46          // TMR1中断服务函数
  47          void TIMR1_IRQHandler(void) interrupt TMR1_IRQn
  48          {
  49   1          // 进入中断设置IP，不可删除
  50   1          __IRQnIPnPush(TMR1_IRQn);
  51   1      
  52   1          // ---------------- 用户函数处理 -------------------
C51 COMPILER V9.60.7.0   TMR1                                                              08/07/2025 17:46:19 PAGE 2   

  53   1      
  54   1          // 周期中断
  55   1          if (TMR1_CONH & TMR_PRD_PND(0x1))
  56   1          {
  57   2              TMR1_CONH |= TMR_PRD_PND(0x1); // 清除pending
  58   2      
  59   2              // if (tmr1_cnt < 4294967295)
  60   2              // {
  61   2              //     tmr1_cnt++;
  62   2              // }
  63   2      
  64   2              // 串口接收超时计数
  65   2              if (flag_is_uart0_receive_timeout_enable)
  66   2              {
  67   3                  uart0_receive_timeout_cnt++;
  68   3              }
  69   2      
  70   2      #if AD_KEY_ENABLE
  71   2              // 在定时器注册按键扫描：
  72   2              // if (ad_key_para.cur_scan_times < 255)
  73   2              {
  74   3                  ad_key_para.cur_scan_times++;
  75   3              }
  76   2      #endif // AD_KEY_ENABLE
  77   2      
  78   2      #if TOUCH_KEY_ENABLE
  79   2              // if (touch_key_para.cur_scan_times < 255)
  80   2              {
  81   3                  touch_key_para.cur_scan_times++;
  82   3              }
  83   2      #endif // TOUCH_KEY_ENABLE
  84   2      
  85   2      #if PIN_LEVEL_SCAN_ENABLE
  86   2              // if (pin_level_scan_time_cnt < 65535) // 防止计数溢出
  87   2              {
  88   3                  pin_level_scan_time_cnt++;
  89   3              }
  90   2      #endif
  91   2      
  92   2      #if FUEL_CAPACITY_SCAN_ENABLE
  93   2              if (flag_timer_scan_update_fuel_gear) // 更新油量挡位
  94   2              {
  95   3                  // if (timer_scan_update_fuel_gear_cnt < 65535)
  96   3                  {
  97   4                      timer_scan_update_fuel_gear_cnt++;
  98   4                      if (timer_scan_update_fuel_gear_cnt >= FUEL_UPDATE_LAST_FUEL_PERCENTAGE_TIME)
  99   4                      // if (timer_scan_update_fuel_gear_cnt >= 5000) // DEBUG 测试用
 100   4                      {
 101   5                          timer_scan_update_fuel_gear_cnt = 0;
 102   5                          flag_update_fuel_gear = 1; // 更新油量挡位
 103   5                      }
 104   4                  }
 105   3              }
 106   2              else
 107   2              {
 108   3                  timer_scan_update_fuel_gear_cnt = 0;
 109   3                  flag_update_fuel_gear = 0;
 110   3              }
 111   2      #endif
 112   2      
 113   2      #if SPEED_SCAN_ENABLE
 114   2              {
C51 COMPILER V9.60.7.0   TMR1                                                              08/07/2025 17:46:19 PAGE 3   

 115   3                  static u16 cnt = 0;
 116   3                  cnt++;
 117   3                  if (cnt >= SPEED_SCAN_BUFF_UPDATE_TIME)
 118   3                  {
 119   4                      cnt = 0;
 120   4                      flag_is_send_speed_time_come = 1;
 121   4                  }
 122   3              }
 123   2      #endif
 124   2      
 125   2      #if ENGINE_SPEED_SCAN_ENABLE
 126   2              {
 127   3                  static u16 cnt = 0;
 128   3                  cnt++;
 129   3                  if (cnt >= ENGINE_SPEED_SEND_PERIOD)
 130   3                  {
 131   4                      cnt = 0;
 132   4                      flag_is_send_engine_speed_time_come = 1;
 133   4                  }
 134   3              }
 135   2      #endif
 136   2      
 137   2              // if (mileage_save_time_cnt < 4294967295 - diff_ms_cnt) // 防止计数溢出
 138   2              if (mileage_save_time_cnt < 65535) // 防止计数溢出
 139   2              {
 140   3                  mileage_save_time_cnt++;
 141   3              }
 142   2      
 143   2      #if FUEL_CAPACITY_SCAN_ENABLE
 144   2              // if (fuel_capacity_scan_cnt < 4294967295 - diff_ms_cnt) // 防止计数溢出
 145   2              {
 146   3                  fuel_capacity_scan_cnt++;
 147   3              }
 148   2      #endif
 149   2      
 150   2              // if (synchronous_request_status == SYN_REQUEST_STATUS_HANDLING)
 151   2              {
 152   3                  synchronous_request_time_cnt++; // 同步请求的冷却计时
 153   3                  // synchronous_request_time_cnt += diff_ms_cnt; // 同步请求的冷却计时
 154   3                  if (synchronous_request_time_cnt >= 2000)
 155   3                  {
 156   4                      // 如果接收同步请求已经过了 xx s，清除冷却状态
 157   4                      synchronous_request_time_cnt = 0;
 158   4                      synchronous_request_status = SYN_REQUEST_STATUS_NONE;
 159   4                  }
 160   3              }
 161   2      
 162   2      #if 0 // 日期和时间合到了一起，就不用这部分程序
                  if (update_date_status == UPDATE_STATUS_HANDLING)
                  {
                      // 如果更新日期进入冷却状态，进行冷却计时
                      // update_date_cooling_cnt++;
                      update_date_cooling_cnt += diff_ms_cnt;
                      if (update_date_cooling_cnt >= 100) // xx ms
                      {
                          // 过了冷却时间，退出冷却状态
                          update_date_cooling_cnt = 0;
                          update_date_status = UPDATE_STATUS_NONE;
                      }
                  }
              #endif
 176   2      
C51 COMPILER V9.60.7.0   TMR1                                                              08/07/2025 17:46:19 PAGE 4   

 177   2              // if (update_time_status == UPDATE_STATUS_HANDLING)
 178   2              {
 179   3                  // 如果更新时间进入冷却状态，进行冷却计时
 180   3                  update_time_cooling_cnt++;
 181   3                  // update_time_cooling_cnt += diff_ms_cnt;
 182   3                  if (update_time_cooling_cnt >= 100) // xx ms
 183   3                  {
 184   4                      // 过了冷却时间，退出冷却状态
 185   4                      update_time_cooling_cnt = 0;
 186   4                      update_time_status = UPDATE_STATUS_NONE;
 187   4                  }
 188   3              }
 189   2      
 190   2              // if (mileage_update_time_cnt < 65535)
 191   2              {
 192   3                  mileage_update_time_cnt++;
 193   3              }
 194   2      
 195   2      #if BATTERY_SCAN_ENABLE
 196   2              // if (battery_scan_time_cnt < 4294967295)
 197   2              {
 198   3                  battery_scan_time_cnt++;
 199   3              }
 200   2      #endif // BATTERY_SCAN_ENABLE
 201   2      
 202   2      #if 0 // DEBUG 只在测试时使用
              
                          {
                              static u16 cnt;
                              cnt++;
                              if (cnt >= 1000)
                              {
                                  cnt = 0;
                                  flag_is_debug_update = 1;
                              }
                          }
              
              #endif // // DEBUG 只在测试时使用
 215   2      
 216   2              // {
 217   2              //     static u16 cnt;
 218   2              //     cnt++;
 219   2              //     if (cnt >= 4000)
 220   2              //     {
 221   2              //         cnt = 0;
 222   2              //         flag_debug_is_send_time = 1; // 发送时间
 223   2              //         // flag_debug_is_send_time_2 = 1;
 224   2              //     }
 225   2              // }
 226   2          }
 227   1      
 228   1          // P20 = 0;// 测试中断持续时间
 229   1          // 退出中断设置IP，不可删除
 230   1          __IRQnIPnPop(TMR1_IRQn);
 231   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    367    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   TMR1                                                              08/07/2025 17:46:19 PAGE 5   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
