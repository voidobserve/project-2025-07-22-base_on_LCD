C51 COMPILER V9.60.7.0   TMR1                                                              08/06/2025 17:46:19 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TMR1
OBJECT MODULE PLACED IN .\Release\Objects\tmr1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\tmr1.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X00
                    -0C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Rele
                    -ase\Listings\tmr1.lst) OBJECT(.\Release\Objects\tmr1.obj)

line level    source

   1          #include "tmr1.h"
   2          
   3          // #define TMR1_CNT_TIME 152 // 152 * 0.65625us 约等于100us
   4          
   5          // 定时器定时周期 (单位:Hz)
   6          // 周期值 = 系统时钟 / 定时器分频 / 频率 - 1
   7          #define TMR1_PERIOD (SYSCLK / 128 / 1000 - 1) // 1000Hz,1ms
   8          
   9          // volatile bit tmr1_flag = 0; // TMR1中断服务函数中会置位的标志位
  10          // volatile u32 tmr1_cnt = 0; // 定时器TMR1的计数值（每次在中断服务函数中会加一）
  11          
  12          /**
  13           * @brief 配置定时器TMR1，配置完成后，定时器默认关闭
  14           */
  15          void tmr1_config(void)
  16          {
  17   1          __SetIRQnIP(TMR1_IRQn, TMR1_IQn_CFG); // 设置中断优先级（TMR1）
  18   1          __DisableIRQ(TMR1_IRQn);              // 禁用中断
  19   1          IE_EA = 1;                            // 打开总中断
  20   1      
  21   1          TMR_ALLCON = TMR1_CNT_CLR(0x1); // 清除计数值
  22   1      
  23   1          TMR1_CONL &= ~TMR_PRESCALE_SEL(0x07); // 清除TMR1的预分频配置寄存器
  24   1          TMR1_CONL |= TMR_PRESCALE_SEL(0x07);  // 定时器预分频
  25   1          TMR1_CONL &= ~TMR_MODE_SEL(0x03);     // 清除TMR1的模式配置寄存器
  26   1          TMR1_CONL |= TMR_MODE_SEL(0x01);      // 配置TMR1的模式为计数器模式，最后对系统时钟
             -的脉冲进行计数
  27   1      
  28   1          TMR1_CONH &= ~TMR_PRD_PND(0x01); // 清除TMR1的计数标志位，表示未完成计数
  29   1          TMR1_CONH |= TMR_PRD_IRQ_EN(1);  // 使能TMR1的计数中断
  30   1      
  31   1          // 配置TMR1的计数周期
  32   1          TMR1_PRH = TMR_PERIOD_VAL_H((TMR1_PERIOD >> 8) & 0xFF); // 周期值
  33   1          TMR1_PRL = TMR_PERIOD_VAL_L((TMR1_PERIOD >> 0) & 0xFF);
  34   1      
  35   1          // TMR1_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除TMR1的时钟源配置寄存器
  36   1          // TMR1_CONL |= TMR_SOURCE_SEL(0x05);    // 配置TMR1的时钟源，不用任何时钟
  37   1      
  38   1          // 重新给TMR1配置时钟
  39   1          TMR1_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
  40   1          TMR1_CONL |= TMR_SOURCE_SEL(0x06);    // 配置定时器的时钟源，使用系统时钟
  41   1      
  42   1          __EnableIRQ(TMR1_IRQn); // 使能中断
  43   1          // IE_EA = 1;              // 打开总中断
  44   1      }
  45          
  46          // TMR1中断服务函数
  47          void TIMR1_IRQHandler(void) interrupt TMR1_IRQn
  48          {
  49   1          // 进入中断设置IP，不可删除
  50   1          __IRQnIPnPush(TMR1_IRQn);
  51   1        
  52   1          // ---------------- 用户函数处理 -------------------
C51 COMPILER V9.60.7.0   TMR1                                                              08/06/2025 17:46:19 PAGE 2   

  53   1      
  54   1          // 周期中断
  55   1          if (TMR1_CONH & TMR_PRD_PND(0x1))
  56   1          {
  57   2              TMR1_CONH |= TMR_PRD_PND(0x1); // 清除pending
  58   2      
  59   2              // if (tmr1_cnt < 4294967295)
  60   2              // {
  61   2              //     tmr1_cnt++;
  62   2              // }
  63   2      
  64   2              {
  65   3      
  66   3                  // 串口接收超时计数
  67   3                  if (flag_is_uart0_receive_timeout_enable)
  68   3                  {
  69   4                      uart0_receive_timeout_cnt++;
  70   4                  }
  71   3      
  72   3      #if AD_KEY_ENABLE
                          // 在定时器注册按键扫描：
                          // if (ad_key_para.cur_scan_times < 255)
                          {
                              ad_key_para.cur_scan_times++;
                          }
              #endif // AD_KEY_ENABLE
  79   3      
  80   3      #if TOUCH_KEY_ENABLE
                          // if (touch_key_para.cur_scan_times < 255)
                          {
                              touch_key_para.cur_scan_times++;
                          }
              #endif // TOUCH_KEY_ENABLE
  86   3      
  87   3      #if PIN_LEVEL_SCAN_ENABLE
                          // if (pin_level_scan_time_cnt < 65535) // 防止计数溢出
                          {
                              pin_level_scan_time_cnt++;
                          }
              #endif
  93   3      
  94   3      #if FUEL_CAPACITY_SCAN_ENABLE
                          if (flag_timer_scan_update_fuel_gear)
                          {
                              // if (timer_scan_update_fuel_gear_cnt < 65535)
                              {
                                  timer_scan_update_fuel_gear_cnt++;
                                  if (timer_scan_update_fuel_gear_cnt >= FUEL_UPDATE_LAST_FUEL_PERCENTAGE_TIME)
                                  // if (timer_scan_update_fuel_gear_cnt >= 5000) // DEBUG 测试用
                                  {
                                      timer_scan_update_fuel_gear_cnt = 0;
                                      flag_update_fuel_gear = 1; // 更新油量挡位
                                  }
                              }
                          }
                          else
                          {
                              timer_scan_update_fuel_gear_cnt = 0;
                              flag_update_fuel_gear = 0;
                          }
              #endif
 114   3      
C51 COMPILER V9.60.7.0   TMR1                                                              08/06/2025 17:46:19 PAGE 3   

 115   3      #if SPEED_SCAN_ENABLE
 116   3                  {
 117   4                      static u16 cnt = 0;
 118   4                      cnt++;
 119   4                      if (cnt >= SPEED_SCAN_BUFF_UPDATE_TIME)
 120   4                      {
 121   5                          cnt = 0;
 122   5                          flag_is_send_speed_time_come = 1;
 123   5                      }
 124   4                  }
 125   3      #endif
 126   3      
 127   3      #if ENGINE_SPEED_SCAN_ENABLE
                          {
                              static u16 cnt = 0;
                              cnt++;
                              if (cnt >= ENGINE_SPEED_SEND_PERIOD)
                              {
                                  cnt = 0;
                                  flag_is_send_engine_speed_time_come = 1;
                              }
                          }
              #endif
 138   3      
 139   3                  // if (mileage_save_time_cnt < 4294967295 - diff_ms_cnt) // 防止计数溢出
 140   3                  if (mileage_save_time_cnt < 65535)
 141   3                  {
 142   4                      mileage_save_time_cnt++;
 143   4                      // mileage_save_time_cnt += diff_ms_cnt;
 144   4                  }
 145   3      
 146   3      #if FUEL_CAPACITY_SCAN_ENABLE
                          // if (fuel_capacity_scan_cnt < 4294967295 - diff_ms_cnt) // 防止计数溢出
                          {
                              fuel_capacity_scan_cnt++;
                              // fuel_capacity_scan_cnt += diff_ms_cnt;
                          }
              #endif
 153   3      
 154   3                  // if (synchronous_request_status == SYN_REQUEST_STATUS_HANDLING)
 155   3                  {
 156   4                      synchronous_request_time_cnt++; // 同步请求的冷却计时
 157   4                      // synchronous_request_time_cnt += diff_ms_cnt; // 同步请求的冷却计时
 158   4                      if (synchronous_request_time_cnt >= 2000)
 159   4                      {
 160   5                          // 如果接收同步请求已经过了 xx s，清除冷却状态
 161   5                          synchronous_request_time_cnt = 0;
 162   5                          synchronous_request_status = SYN_REQUEST_STATUS_NONE;
 163   5                      }
 164   4                  }
 165   3      
 166   3      #if 0 // 日期和时间合到了一起，就不用这部分程序
                  if (update_date_status == UPDATE_STATUS_HANDLING)
                  {
                      // 如果更新日期进入冷却状态，进行冷却计时
                      // update_date_cooling_cnt++;
                      update_date_cooling_cnt += diff_ms_cnt;
                      if (update_date_cooling_cnt >= 100) // xx ms
                      {
                          // 过了冷却时间，退出冷却状态
                          update_date_cooling_cnt = 0;
                          update_date_status = UPDATE_STATUS_NONE;
C51 COMPILER V9.60.7.0   TMR1                                                              08/06/2025 17:46:19 PAGE 4   

                      }
                  }
              #endif
 180   3      
 181   3                  // if (update_time_status == UPDATE_STATUS_HANDLING)
 182   3                  {
 183   4                      // 如果更新时间进入冷却状态，进行冷却计时
 184   4                      update_time_cooling_cnt++;
 185   4                      // update_time_cooling_cnt += diff_ms_cnt;
 186   4                      if (update_time_cooling_cnt >= 100) // xx ms
 187   4                      {
 188   5                          // 过了冷却时间，退出冷却状态
 189   5                          update_time_cooling_cnt = 0;
 190   5                          update_time_status = UPDATE_STATUS_NONE;
 191   5                      }
 192   4                  }
 193   3      
 194   3                  // if (mileage_update_time_cnt < 65535)
 195   3                  {
 196   4                      mileage_update_time_cnt++;
 197   4                  }
 198   3      
 199   3      #if BATTERY_SCAN_ENABLE
                          // if (battery_scan_time_cnt < 4294967295)
                          {
                              battery_scan_time_cnt++;
                          }
              #endif // BATTERY_SCAN_ENABLE
 205   3      
 206   3      #if 0 // DEBUG 只在测试时使用
              
                          {
                              static u16 cnt;
                              cnt++;
                              if (cnt >= 1000)
                              {
                                  cnt = 0;
                                  flag_is_debug_update = 1;
                              }
                          }
              
              #endif // // DEBUG 只在测试时使用
 219   3      
 220   3                  {
 221   4                      static u16 cnt;
 222   4                      cnt++;
 223   4                      if (cnt >= 4000)
 224   4                      {
 225   5                          cnt = 0;
 226   5                          flag_debug_is_send_time = 1; // 发送时间
 227   5                          // flag_debug_is_send_time_2 = 1;
 228   5                      }
 229   4                  }
 230   3              }
 231   2          }
 232   1      
 233   1          // P20 = 0;// 测试中断持续时间
 234   1          // 退出中断设置IP，不可删除
 235   1          __IRQnIPnPop(TMR1_IRQn);
 236   1      }


C51 COMPILER V9.60.7.0   TMR1                                                              08/06/2025 17:46:19 PAGE 5   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    296    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
