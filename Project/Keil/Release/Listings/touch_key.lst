C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/11/2025 11:11:29 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TOUCH_KEY
OBJECT MODULE PLACED IN .\Release\Objects\touch_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\touch_key.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X0
                    -00C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Rel
                    -ease\Listings\touch_key.lst) OBJECT(.\Release\Objects\touch_key.obj)

line level    source

   1          #include "touch_key.h"
   2          
   3          #if TOUCH_KEY_ENABLE
   4          /*
   5              æ ‡å¿—ä½ï¼Œè§¦æ‘¸æŒ‰é”®çš„æ‰«æå‘¨æœŸæ˜¯å¦åˆ°æ¥
   6              ç”±å®šæ—¶å™¨ä¸­æ–­ç½®ä½ï¼Œæ‰«æå‡½æ•°ä¸­åˆ¤æ–­è¯¥æ ‡å¿—ä½çš„çŠ¶æ€ï¼Œå†å†³å®šæ˜¯å¦è¦è¿›è¡ŒæŒ‰é”®
             -æ‰«æ
   7          */
   8          // volatile bit flag_is_touch_key_scan_circle_arrived;
   9          
  10          // å®šä¹‰è§¦æ‘¸æŒ‰é”®çš„æŒ‰é”®äº‹ä»¶
  11          enum TOUCH_KEY_EVENT
  12          {
  13              TOUCH_KEY_EVENT_NONE = 0,
  14              TOUCH_KEY_EVENT_ID_1_CLICK,
  15              TOUCH_KEY_EVENT_ID_1_DOUBLE,
  16              TOUCH_KEY_EVENT_ID_1_LONG,
  17              TOUCH_KEY_EVENT_ID_1_HOLD,
  18              TOUCH_KEY_EVENT_ID_1_LOOSE,
  19          
  20              TOUCH_KEY_EVENT_ID_2_CLICK,
  21              TOUCH_KEY_EVENT_ID_2_DOUBLE,
  22              TOUCH_KEY_EVENT_ID_2_LONG,
  23              TOUCH_KEY_EVENT_ID_2_HOLD,
  24              TOUCH_KEY_EVENT_ID_2_LOOSE,
  25          };
  26          
  27          #define TOUCH_KEY_EFFECT_EVENT_NUMS (5) // å•ä¸ªè§¦æ‘¸æŒ‰é”®çš„æœ‰æ•ˆæŒ‰é”®äº‹ä»¶ä¸ªæ•°
  28          // å°†æŒ‰é”®idå’ŒæŒ‰é”®äº‹ä»¶ç»‘å®šèµ·æ¥ï¼Œåœ¨ xx å‡½æ•°ä¸­ï¼Œé€šè¿‡æŸ¥è¡¨çš„æ–¹å¼å¾—åˆ°æŒ‰é”®äº‹ä»¶
  29          static const u8 touch_key_event_table[][TOUCH_KEY_EFFECT_EVENT_NUMS + 1] = {
  30              // [0]--æŒ‰é”®å¯¹åº”çš„idå·ï¼Œç”¨äºæŸ¥è¡¨ï¼Œ[1]ã€[2]ã€[3]...--ç”¨äºä¸ key_driver.h ä¸­å®šä¹‰çš„æ
             -Œ‰é”®äº‹ä»¶KEY_EVENTç»‘å®šå…³ç³»(ä¸€å®šè¦ä¸€ä¸€å¯¹åº”)
  31              {TOUCH_KEY_ID_1, TOUCH_KEY_EVENT_ID_1_CLICK, TOUCH_KEY_EVENT_ID_1_DOUBLE, TOUCH_KEY_EVENT_ID_1_LONG, T
             -OUCH_KEY_EVENT_ID_1_HOLD, TOUCH_KEY_EVENT_ID_1_LOOSE}, //
  32              {TOUCH_KEY_ID_2, TOUCH_KEY_EVENT_ID_2_CLICK, TOUCH_KEY_EVENT_ID_2_DOUBLE, TOUCH_KEY_EVENT_ID_2_LONG, T
             -OUCH_KEY_EVENT_ID_2_HOLD, TOUCH_KEY_EVENT_ID_2_LOOSE}, //
  33          };
  34          
  35          extern u8 touch_key_get_key_id(void);
  36          volatile struct key_driver_para touch_key_para = {
  37              // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™ï¼š
  38              // .scan_times = 10,   // æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
  39              // .last_key = NO_KEY, // ä¸Šä¸€æ¬¡å¾—åˆ°çš„æŒ‰é”®é”®å€¼ï¼Œåˆå§‹åŒ–ä¸ºæ— æ•ˆçš„é”®å€¼
  40              // // .filter_value = NO_KEY, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´å¾—åˆ°çš„é”®å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨
             -)ï¼Œåˆå§‹åŒ–ä¸º NO_KEY
  41              // // .filter_cnt = 0, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´çš„ç´¯åŠ å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨)ï¼Œåˆå§‹
             -åŒ–ä¸º0
  42              // .filter_time = 3,       // æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
  43              // .long_time = 50,        // åˆ¤å®šæŒ‰é”®æ˜¯é•¿æŒ‰å¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
  44              // .hold_time = (75 + 15), // åˆ¤å®šæŒ‰é”®æ˜¯HOLDå¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
  45              // // .press_cnt = 0, // ä¸long_timeå’Œhold_timeå¯¹æ¯”, åˆ¤æ–­é•¿æŒ‰äº‹ä»¶å’ŒHOLDäº‹ä»¶
  46              // // .click_cnt = 0,
  47              // .click_delay_time = 20, // æŒ‰é”®æŠ¬èµ·åï¼Œç­‰å¾…è¿å‡»çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/11/2025 11:11:29 PAGE 2   

  48              // // .notify_value = 0,
  49              // .key_type = KEY_TYPE_AD, // æŒ‰é”®ç±»å‹ä¸ºadæŒ‰é”®
  50              // .get_value = ad_key_get_key_id,
  51          
  52              // .latest_key_val = AD_KEY_ID_NONE,
  53              // .latest_key_event = KEY_EVENT_NONE,
  54          
  55              TOUCH_KEY_SCAN_CIRCLE_TIMES,
  56              0,
  57              // NO_KEY,
  58              0,
  59          
  60              0,
  61              0,
  62              3,
  63          
  64              TOUCH_KEY_LONG_PRESS_TIME_THRESHOLD_MS / TOUCH_KEY_SCAN_CIRCLE_TIMES,
  65              (TOUCH_KEY_LONG_PRESS_TIME_THRESHOLD_MS + TOUCH_KEY_HOLD_PRESS_TIME_THRESHOLD_MS) / TOUCH_KEY_SCAN_CIR
             -CLE_TIMES,
  66              0,
  67          
  68              0,
  69              0,
  70              // 200 / TOUCH_KEY_SCAN_CIRCLE_TIMES,
  71              0,
  72              // NO_KEY,
  73              0,
  74              KEY_TYPE_TOUCH,
  75              touch_key_get_key_id,
  76          
  77              TOUCH_KEY_ID_NONE,
  78              KEY_EVENT_NONE,
  79          };
  80          
  81          static u8 touch_key_get_key_id(void)
  82          {
  83   1          unsigned long tk_key_val = 0;
  84   1          u8 ret = NO_KEY;
  85   1      
  86   1      
  87   1          // delay_ms(1); // å»¶æ—¶å¹¶ä¸èƒ½è§£å†³åˆšä¸Šç‚¹å°±æ£€æµ‹åˆ°é•¿æŒ‰çš„é—®é¢˜
  88   1      
  89   1          // printf("touch key scan\n");
  90   1      
  91   1          tk_key_val = __tk_key_flag;
  92   1      #if 1
  93   1          if (TK_CH9_VALIB == __tk_key_flag)
  94   1          {
  95   2              ret = TOUCH_KEY_ID_1;
  96   2              // return TOUCH_KEY_ID_1;
  97   2          }
  98   1          else if (TK_CH10_VALIB == __tk_key_flag)
  99   1          {
 100   2              ret = TOUCH_KEY_ID_2;
 101   2              // return TOUCH_KEY_ID_2;
 102   2          }
 103   1          else
 104   1          {
 105   2              // return TOUCH_KEY_ID_NONE;
 106   2              // return NO_KEY;
 107   2          }
 108   1      #endif
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/11/2025 11:11:29 PAGE 3   

 109   1      
 110   1      #if 0
                  if (TK_CH10_VALIB == __tk_key_flag)
                  {
                      ret = TOUCH_KEY_ID_2;
                      // return TOUCH_KEY_ID_1;
                  }
                  else if (TK_CH9_VALIB == __tk_key_flag)
                  {
                      ret = TOUCH_KEY_ID_1;
                      // return TOUCH_KEY_ID_2;
                  }
                  else
                  {
                      // return TOUCH_KEY_ID_NONE;
                      // return NO_KEY;
                  }
              #endif
 127   1      
 128   1          tk_key_val = 0;
 129   1      
 130   1          // return __tk_key_flag;        // __tk_key_flag å•æ¬¡æŒ‰é”®æ ‡å¿—
 131   1          return ret;
 132   1      }
 133          
 134          /**
 135           * @brief å°†æŒ‰é”®å€¼å’Œkey_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
 136           *
 137           * @param key_val è§¦æ‘¸æŒ‰é”®é”®å€¼
 138           * @param key_event åœ¨key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
 139           * @return u8 åœ¨touch_key_event_tableä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› TOUCH_KEY_
             -EVENT_NONE
 140           */
 141          static u8 __touch_key_get_event(const u8 key_val, const u8 key_event)
 142          {
 143   1          volatile u8 ret_key_event = TOUCH_KEY_EVENT_NONE;
 144   1          u8 i = 0;
 145   1          for (; i < ARRAY_SIZE(touch_key_event_table); i++)
 146   1          {
 147   2              // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•ˆï¼Œ
             -éœ€è¦æ‰‹åŠ¨ä¿®æ”¹
 148   2              if (key_val == touch_key_event_table[i][0])
 149   2              {
 150   3                  ret_key_event = touch_key_event_table[i][key_event];
 151   3                  break;
 152   3              }
 153   2          }
 154   1      
 155   1          return ret_key_event;
 156   1      }
 157          
 158          void touch_key_handle(void)
 159          {
 160   1          u8 touch_key_event = TOUCH_KEY_EVENT_NONE;
 161   1      
 162   1          if (touch_key_para.latest_key_val == TOUCH_KEY_ID_NONE)
 163   1          {
 164   2              return;
 165   2          }
 166   1      
 167   1          touch_key_event = __touch_key_get_event(touch_key_para.latest_key_val, touch_key_para.latest_key_event
             -);
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/11/2025 11:11:29 PAGE 4   

 168   1          touch_key_para.latest_key_val = TOUCH_KEY_ID_NONE;
 169   1          touch_key_para.latest_key_event = KEY_EVENT_NONE;
 170   1      
 171   1          switch (touch_key_event)
 172   1          {
 173   2          case TOUCH_KEY_EVENT_ID_1_CLICK:
 174   2              // printf("touch key 1 click\n");
 175   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_CLICK_MSG << 16 | TOUCH_KEY_SEND_INFO_1);
 176   2              break;
 177   2      
 178   2          case TOUCH_KEY_EVENT_ID_1_DOUBLE:
 179   2              // printf("touch key 1 double\n");
 180   2              break;
 181   2      
 182   2          case TOUCH_KEY_EVENT_ID_1_LONG:
 183   2              // printf("touch key 1 long\n");
 184   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LONG_MSG << 16 | TOUCH_KEY_SEND_INFO_1);
 185   2              break;
 186   2      
 187   2          case TOUCH_KEY_EVENT_ID_1_HOLD:
 188   2              // printf("touch key 1 hold\n");
 189   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_HOLD_MSG << 16 | TOUCH_KEY_SEND_INFO_1);
 190   2              break;
 191   2      
 192   2          case TOUCH_KEY_EVENT_ID_1_LOOSE:
 193   2              // printf("touch key 1 loose\n");
 194   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LOOSE_MSG << 16 | TOUCH_KEY_SEND_INFO_1);
 195   2              break;
 196   2          case TOUCH_KEY_EVENT_ID_2_CLICK:
 197   2              // printf("touch key 2 click\n");
 198   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_CLICK_MSG << 16 | TOUCH_KEY_SEND_INFO_2);
 199   2              break;
 200   2      
 201   2          case TOUCH_KEY_EVENT_ID_2_DOUBLE:
 202   2              // printf("touch key 2 double\n");
 203   2              break;
 204   2      
 205   2          case TOUCH_KEY_EVENT_ID_2_LONG:
 206   2              // printf("touch key 2 long\n");
 207   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LONG_MSG << 16 | TOUCH_KEY_SEND_INFO_2);
 208   2              break;
 209   2      
 210   2          case TOUCH_KEY_EVENT_ID_2_HOLD:
 211   2              // printf("touch key 2 hold\n");
 212   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_HOLD_MSG << 16 | TOUCH_KEY_SEND_INFO_2);
 213   2              break;
 214   2      
 215   2          case TOUCH_KEY_EVENT_ID_2_LOOSE:
 216   2              // printf("touch key 2 loose\n");
 217   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LOOSE_MSG << 16 | TOUCH_KEY_SEND_INFO_2);
 218   2              break;
 219   2      
 220   2          default:
 221   2              break;
 222   2          }
 223   1      }
 224          
 225          /**
 226           * @brief __is_double_click() åˆ¤æ–­æ˜¯å¦æœ‰åŒå‡»åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®,å†…éƒ¨æœ€é•¿å»¶æ—¶æ—¶é—´ï¼šDETECT
             -_DOUBLE_CLICK_INTERVAL
 227           *
 228           * @param touch_key_id_const
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/11/2025 11:11:29 PAGE 5   

 229           * @return u8 0--æ²¡æœ‰åŒå‡»åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®ï¼Œ1--åŒå‡»äº†åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®
 230           */
 231          // u8 __is_double_click(const u32 touch_key_id_const)
 232          // {
 233          //     u8 i = 0;                   // å¾ªç¯è®¡æ•°å€¼
 234          //     volatile u32 touch_key = 0; // å­˜æ”¾æ¯æ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®
 235          
 236          //     for (; i < DETECT_DOUBLE_CLICK_INTERVAL; i++)
 237          //     {
 238          //         delay_ms(1);
 239          //         __tk_scan();
 240          //         touch_key = __tk_key_flag;
 241          
 242          //         if (touch_key_id_const == touch_key)
 243          //         {
 244          //             // å¦‚æœæ£€æµ‹åˆ°æ˜¯åŒä¸€ä¸ªæŒ‰é”®æŒ‰ä¸‹ï¼Œè¯´æ˜æ˜¯åŒå‡»
 245          //             return 1; // åŒå‡»äº†åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®ï¼Œè¿”å›1
 246          //         }
 247          //     }
 248          
 249          //     return 0; // æ²¡æœ‰åŒå‡»åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®ï¼Œè¿”å›0
 250          // }
 251          
 252          // ä½¿ç”¨touch_keyä¹‹å‰ï¼Œå…ˆè°ƒç”¨å®˜æ–¹æä¾›çš„è§¦æ‘¸æ¨¡å—çš„åˆå§‹åŒ–å‡½æ•° tk_param_init();
 253          // void touch_key_scan(void)
 254          // {
 255          
 256          // #if 0
 257          //     // static volatile u8 filter_cnt = 0; // æŒ‰é”®æ¶ˆæŠ–ä½¿ç”¨åˆ°çš„å˜é‡
 258          //     volatile u32 touch_key = 0;                   // __tk_key_flag å•æ¬¡æŒ‰é”®æ ‡å¿—
 259          //     static volatile u32 touch_key_last = 0;                // ç”¨äºå­˜æ”¾é•¿æŒ‰æ—¶ï¼Œå¯¹åº”çš„æŒ‰é”®
 260          //     static volatile u32 touch_time_cnt = 0;       // é•¿æŒ‰è®¡æ•°å€¼
 261          //     static volatile u8 touch_key_scan_status = 0; // éé˜»å¡çš„æŒ‰é”®æ‰«æå‡½æ•°ä¸­ï¼Œä½¿ç”¨çš„çŠ¶æ€
             -æœº
 262          
 263          //     if (0 == flag_is_touch_key_scan_circle_arrived)
 264          //     {
 265          //         // å¦‚æœæ‰«æå‘¨æœŸæ²¡æœ‰åˆ°æ¥ï¼Œä¸æ‰§è¡ŒæŒ‰é”®æ‰«æ
 266          //         return;
 267          //     }
 268          
 269          //     flag_is_touch_key_scan_circle_arrived = 0;
 270          
 271          //     WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
 272          //     /* æŒ‰é”®æ‰«æå‡½æ•° */
 273          //     __tk_scan();                 // ä½¿ç”¨äº†åº“é‡Œé¢çš„æ¥å£ï¼ˆé—­æºåº“ï¼‰
 274          //     WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
 275          //     touch_key = __tk_key_flag;   // __tk_key_flag å•æ¬¡æŒ‰é”®æ ‡å¿—
 276          
 277          //     if (TOUCH_KEY_SCAN_STATUS_NONE == touch_key_scan_status) // æœªæ£€æµ‹åˆ°æŒ‰é”®æ—¶
 278          //     {
 279          //         // å¦‚æœæœ‰æŒ‰é”®æŒ‰ä¸‹ï¼ˆå¹¶ä¸”ä¹‹å‰æ‰«æåˆ°çš„ä¸æ˜¯é•¿æŒ‰ï¼‰
 280          
 281          //         // åˆ¤æ–­æ˜¯å¦ä¸ºé•¿æŒ‰ï¼š
 282          
 283          //         if (touch_key_last == 0) // å¦‚æœä¹‹å‰æœªæ£€æµ‹åˆ°æŒ‰é”®
 284          //         {
 285          //             touch_key_last = touch_key;
 286          //         }
 287          //         else if (touch_key_last == touch_key)
 288          //         {
 289          //             // å¦‚æœä¸Šæ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸æ­¤æ¬¡çš„æŒ‰é”®ç›¸ç­‰ï¼Œè¯´æ˜æŒ‰é”®è¿˜æœªæ¾å¼€
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/11/2025 11:11:29 PAGE 6   

 290          //             touch_time_cnt += (TOUCH_KEY_SCAN_CIRCLE_TIMES);
 291          
 292          //             if (touch_time_cnt >= LONG_PRESS_TIME_THRESHOLD_MS)
 293          //             {
 294          //                 // å¦‚æœé•¿æŒ‰è¶…è¿‡äº†è®¾ç½®çš„é•¿æŒ‰æ—¶é—´
 295          //                 // è·³è½¬åˆ°é•¿æŒ‰å¤„ç†
 296          //                 touch_time_cnt = 0; // æ¸…é™¤é•¿æŒ‰æ—¶é—´è®¡æ•°
 297          //                 // printf("long press\n");
 298          //                 touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_HANDLE_LONG_PRESS;
 299          //             }
 300          //         }
 301          //         else
 302          //         {
 303          //             // å¦‚æœä¸Šæ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸æ­¤æ¬¡çš„æŒ‰é”®ä¸ç›¸ç­‰ï¼Œå¹¶ä¸”ä¸Šæ¬¡æ£€æµ‹åˆ°çš„æŒ‰é
             -”®ä¸ç­‰äº0
 304          //             // touch_time_cnt = 0; // æ¸…é™¤é•¿æŒ‰æ—¶é—´è®¡æ•°ï¼ˆå¯ä»¥ç•™åˆ°æ”¶å°¾å¤„ç†ï¼‰
 305          
 306          //             // è·³è½¬åˆ°çŸ­æŒ‰å¤„ç†
 307          //             touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_HANDLE_SHORT_PRESS;
 308          
 309          //             // printf("short press\n");
 310          //         }
 311          
 312          //         // delay_ms(1); //
 313          //     }
 314          
 315          //     if (TOUCH_KEY_SCAN_STATUS_IS_HANDLE_SHORT_PRESS == touch_key_scan_status)
 316          //     {
 317          //         // å¦‚æœæ˜¯æ­£åœ¨å¤„ç†çŸ­æŒ‰
 318          //         bit flag_is_double_click = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦æœ‰æŒ‰é”®åŒå‡»
 319          
 320          //         if (TOUCH_KEY_ID_1 == touch_key_last)
 321          //         {
 322          //             // å¦‚æœKEY1è¢«è§¦æ‘¸
 323          //             flag_is_double_click = __is_double_click(touch_key_last);
 324          //             if (flag_is_double_click)
 325          //             {
 326          //                 // å¦‚æœæœ‰æŒ‰é”®åŒå‡»
 327          //                 printf("k1 double press\n");
 328          // #if USE_MY_DEBUG
 329          //                 printf("k1 double press\n");
 330          // #endif
 331          //                 // send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY1); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€
             -¼
 332          //             }
 333          //             else
 334          //             {
 335          //                 // å¦‚æœæ²¡æœ‰æŒ‰é”®åŒå‡»ï¼Œè¯´æ˜æ˜¯çŸ­æŒ‰
 336          //                 printf("k1 press\n");
 337          // #if USE_MY_DEBUG
 338          //                 printf("k1 press\n");
 339          // #endif
 340          //                 // send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY1); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€¼
 341          //             }
 342          
 343          //             touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_WAIT_SHORT_PRESS_RELEASE; // ç­‰å¾…æŒ‰é”®æ
             -¾å¼€
 344          //         }
 345          //         else if (TOUCH_KEY_ID_2 == touch_key_last)
 346          //         {
 347          //             // å¦‚æœKEY2è¢«è§¦æ‘¸
 348          //             flag_is_double_click = __is_double_click(touch_key_last);
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/11/2025 11:11:29 PAGE 7   

 349          //             if (flag_is_double_click)
 350          //             {
 351          //                 // å¦‚æœæœ‰æŒ‰é”®åŒå‡»
 352          //                 printf("k2 double press\n");
 353          // #if USE_MY_DEBUG
 354          //                 printf("k2 double press\n");
 355          // #endif
 356          //                 // send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY2); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€
             -¼
 357          //             }
 358          //             else
 359          //             {
 360          //                 // å¦‚æœæ²¡æœ‰æŒ‰é”®åŒå‡»ï¼Œè¯´æ˜æ˜¯çŸ­æŒ‰
 361          //                 printf("k2 press\n");
 362          // #if USE_MY_DEBUG
 363          //                 printf("k2 press\n");
 364          // #endif
 365          //                 // send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY2); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€¼
 366          //             }
 367          
 368          //             touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_WAIT_SHORT_PRESS_RELEASE; // ç­‰å¾…æŒ‰é”®æ
             -¾å¼€
 369          //         }
 370          //     }
 371          
 372          //     if (TOUCH_KEY_SCAN_STATUS_IS_HANDLE_LONG_PRESS == touch_key_scan_status)
 373          //     {
 374          //         // å¤„ç†é•¿æŒ‰
 375          //         if (TOUCH_KEY_ID_1 == touch_key)
 376          //         {
 377          //             // å¦‚æœKEY1è¢«è§¦æ‘¸
 378          //             printf("k1 long press\n");
 379          // #if USE_MY_DEBUG
 380          //             printf("k1 long press\n");
 381          // #endif
 382          //             // send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY1);
 383          //         }
 384          //         else if (TOUCH_KEY_ID_2 == touch_key)
 385          //         {
 386          //             // å¦‚æœKEY2è¢«è§¦æ‘¸
 387          //             printf("k2 long press\n");
 388          // #if USE_MY_DEBUG
 389          //             printf("k2 long press\n");
 390          // #endif
 391          //             // send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY2);
 392          //         }
 393          
 394          //         touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_HANDLE_HOLD_PRESS; // è·³è½¬åˆ°é•¿æŒ‰æŒç»­
 395          //     }
 396          
 397          //     if (TOUCH_KEY_SCAN_STATUS_IS_HANDLE_HOLD_PRESS == touch_key_scan_status)
 398          //     {
 399          //         // å¤„ç†é•¿æŒ‰æŒç»­
 400          
 401          //         if (touch_key_last == touch_key)
 402          //         {
 403          //             touch_time_cnt += TOUCH_KEY_SCAN_CIRCLE_TIMES;
 404          //             if (TOUCH_KEY_ID_1 == touch_key)
 405          //             {
 406          //                 if (touch_time_cnt >= HOLD_PRESS_TIME_THRESHOLD_MS)
 407          //                 {
 408          //                     touch_time_cnt = 0;
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/11/2025 11:11:29 PAGE 8   

 409          //                     printf("k1 continue press\n");
 410          // #if USE_MY_DEBUG
 411          //                     printf("k1 continue press\n");
 412          // #endif
 413          //                     // send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY1);
 414          //                 }
 415          //             }
 416          //             else if (TOUCH_KEY_ID_2 == touch_key)
 417          //             {
 418          //                 if (touch_time_cnt >= HOLD_PRESS_TIME_THRESHOLD_MS)
 419          //                 {
 420          //                     touch_time_cnt = 0;
 421          //                     printf("k2 continue press\n");
 422          // #if USE_MY_DEBUG
 423          //                     printf("k2 continue press\n");
 424          // #endif
 425          //                     // send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY2);
 426          //                 }
 427          //             }
 428          
 429          //             // delay_ms(1);
 430          //         }
 431          //         else
 432          //         {
 433          //             // å¦‚æœä¹‹å‰æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸å½“å‰æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸ä¸€è‡´ï¼Œ
 434          //             // è¯´æ˜ å¯èƒ½æ¾å¼€äº†æ‰‹ æˆ–æ˜¯ ä¸€åªæ‰‹æŒ‰ä½äº†åŸæ¥çš„æŒ‰é”®å¦ä¸€åªæ‰‹æŒ‰äº†å…¶ä
             -»–æŒ‰é”®
 435          
 436          //             // è·³è½¬åˆ°ç­‰å¾…é•¿æŒ‰æ¾å¼€
 437          //             touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_WAIT_LONG_PRESS_RELEASE;
 438          //         }
 439          //     }
 440          
 441          //     if ((TOUCH_KEY_SCAN_STATUS_IS_WAIT_LONG_PRESS_RELEASE == touch_key_scan_status) ||
 442          //         (TOUCH_KEY_SCAN_STATUS_IS_WAIT_SHORT_PRESS_RELEASE == touch_key_scan_status))
 443          //     {
 444          //         // å¦‚æœæ˜¯ç­‰å¾…æŒ‰é”®æ¾å¼€
 445          //         static volatile u16 loose_cnt = 0; // å­˜æ”¾æ¾æ‰‹è®¡æ•°å€¼
 446          
 447          //         if (touch_key == 0)
 448          //         {
 449          //             loose_cnt += TOUCH_KEY_SCAN_CIRCLE_TIMES;
 450          //             delay_ms(1);
 451          //         }
 452          //         else
 453          //         {
 454          //             // åªè¦æœ‰ä¸€æ¬¡æ£€æµ‹åˆ°æŒ‰é”®ï¼Œè¯´æ˜æ²¡æœ‰æ¾å¼€æ‰‹
 455          //             loose_cnt = 0;
 456          //         }
 457          
 458          //         if (loose_cnt >= LOOSE_PRESS_CNT_MS) // è¿™é‡Œçš„æ¯”è¾ƒå€¼éœ€è¦æ³¨æ„ï¼Œä¸èƒ½å¤§äºå˜é‡ç±»å
             -‹å¯¹åº”çš„æœ€å¤§å€¼
 459          //         {
 460          //             loose_cnt = 0; // æ¸…ç©ºæ¾æ‰‹è®¡æ•°
 461          //             // å¦‚æœ xx mså†…æ²¡æœ‰æ£€æµ‹åˆ°æŒ‰é”®æŒ‰ä¸‹ï¼Œè¯´æ˜å·²ç»æ¾å¼€æ‰‹
 462          
 463          //             if (TOUCH_KEY_SCAN_STATUS_IS_WAIT_LONG_PRESS_RELEASE == touch_key_scan_status)
 464          //             {
 465          //                 if (TOUCH_KEY_ID_1 == touch_key_last)
 466          //                 {
 467          //                     printf("k1 long press loose\n");
 468          // #if USE_MY_DEBUG
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/11/2025 11:11:29 PAGE 9   

 469          //                     printf("k1 long press loose\n");
 470          // #endif
 471          //                     // send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY1);
 472          //                 }
 473          //                 else if (TOUCH_KEY_ID_2 == touch_key_last)
 474          //                 {
 475          //                     printf("k2 long press loose\n");
 476          // #if USE_MY_DEBUG
 477          //                     printf("k2 long press loose\n");
 478          // #endif
 479          //                     // send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY2);
 480          //                 }
 481          //             }
 482          
 483          //             touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_END; // è·³è½¬åˆ°æ”¶å°¾å¤„ç†
 484          //         }
 485          //     }
 486          
 487          //     if (TOUCH_KEY_SCAN_STATUS_IS_END == touch_key_scan_status)
 488          //     {
 489          //         // æ”¶å°¾å¤„ç†
 490          //         touch_key = 0;
 491          //         touch_key_last = 0;
 492          //         touch_time_cnt = 0;
 493          
 494          //         touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_NONE;
 495          //     }
 496          // #endif
 497          // }
 498          
 499          // void touch_key_handle(void)
 500          // {
 501          // }
 502          
 503          
 504          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    304    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     31       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
