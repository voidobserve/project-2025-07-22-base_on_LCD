C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/24/2025 15:43:43 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TOUCH_KEY
OBJECT MODULE PLACED IN .\Release\Objects\touch_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\touch_key.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X0
                    -00C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Rel
                    -ease\Listings\touch_key.lst) OBJECT(.\Release\Objects\touch_key.obj)

line level    source

   1          #include "touch_key.h"
   2          
   3          #if TOUCH_KEY_ENABLE
   4          /*
   5              æ ‡å¿—ä½ï¼Œè§¦æ‘¸æŒ‰é”®çš„æ‰«æå‘¨æœŸæ˜¯å¦åˆ°æ¥
   6              ç”±å®šæ—¶å™¨ä¸­æ–­ç½®ä½ï¼Œæ‰«æå‡½æ•°ä¸­åˆ¤æ–­è¯¥æ ‡å¿—ä½çš„çŠ¶æ€ï¼Œå†å†³å®šæ˜¯å¦è¦è¿›è¡ŒæŒ‰é”®
             -æ‰«æ
   7          */
   8          // volatile bit flag_is_touch_key_scan_circle_arrived;
   9          
  10          // å®šä¹‰è§¦æ‘¸æŒ‰é”®çš„æŒ‰é”®äº‹ä»¶
  11          enum TOUCH_KEY_EVENT
  12          {
  13              TOUCH_KEY_EVENT_NONE = 0,
  14              TOUCH_KEY_EVENT_ID_1_CLICK,
  15              TOUCH_KEY_EVENT_ID_1_DOUBLE,
  16              TOUCH_KEY_EVENT_ID_1_LONG,
  17              TOUCH_KEY_EVENT_ID_1_HOLD,
  18              TOUCH_KEY_EVENT_ID_1_LOOSE,
  19          
  20              TOUCH_KEY_EVENT_ID_2_CLICK,
  21              TOUCH_KEY_EVENT_ID_2_DOUBLE,
  22              TOUCH_KEY_EVENT_ID_2_LONG,
  23              TOUCH_KEY_EVENT_ID_2_HOLD,
  24              TOUCH_KEY_EVENT_ID_2_LOOSE,
  25          };
  26          
  27          #define TOUCH_KEY_EFFECT_EVENT_NUMS (5) // å•ä¸ªè§¦æ‘¸æŒ‰é”®çš„æœ‰æ•ˆæŒ‰é”®äº‹ä»¶ä¸ªæ•°
  28          // å°†æŒ‰é”®idå’ŒæŒ‰é”®äº‹ä»¶ç»‘å®šèµ·æ¥ï¼Œåœ¨ xx å‡½æ•°ä¸­ï¼Œé€šè¿‡æŸ¥è¡¨çš„æ–¹å¼å¾—åˆ°æŒ‰é”®äº‹ä»¶
  29          static const u8 touch_key_event_table[][TOUCH_KEY_EFFECT_EVENT_NUMS + 1] = {
  30              // [0]--æŒ‰é”®å¯¹åº”çš„idå·ï¼Œç”¨äºæŸ¥è¡¨ï¼Œ[1]ã€[2]ã€[3]...--ç”¨äºä¸ key_driver.h ä¸­å®šä¹‰çš„æ
             -Œ‰é”®äº‹ä»¶KEY_EVENTç»‘å®šå…³ç³»(ä¸€å®šè¦ä¸€ä¸€å¯¹åº”)
  31              {TOUCH_KEY_ID_1, TOUCH_KEY_EVENT_ID_1_CLICK, TOUCH_KEY_EVENT_ID_1_DOUBLE, TOUCH_KEY_EVENT_ID_1_LONG, T
             -OUCH_KEY_EVENT_ID_1_HOLD, TOUCH_KEY_EVENT_ID_1_LOOSE}, //
  32              {TOUCH_KEY_ID_2, TOUCH_KEY_EVENT_ID_2_CLICK, TOUCH_KEY_EVENT_ID_2_DOUBLE, TOUCH_KEY_EVENT_ID_2_LONG, T
             -OUCH_KEY_EVENT_ID_2_HOLD, TOUCH_KEY_EVENT_ID_2_LOOSE}, //
  33          };
  34          
  35          extern u8 touch_key_get_key_id(void);
  36          volatile struct key_driver_para touch_key_para = {
  37              // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™ï¼š
  38              // .scan_times = 10,   // æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
  39              // .last_key = NO_KEY, // ä¸Šä¸€æ¬¡å¾—åˆ°çš„æŒ‰é”®é”®å€¼ï¼Œåˆå§‹åŒ–ä¸ºæ— æ•ˆçš„é”®å€¼
  40              // // .filter_value = NO_KEY, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´å¾—åˆ°çš„é”®å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨
             -)ï¼Œåˆå§‹åŒ–ä¸º NO_KEY
  41              // // .filter_cnt = 0, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´çš„ç´¯åŠ å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨)ï¼Œåˆå§‹
             -åŒ–ä¸º0
  42              // .filter_time = 3,       // æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
  43              // .long_time = 50,        // åˆ¤å®šæŒ‰é”®æ˜¯é•¿æŒ‰å¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
  44              // .hold_time = (75 + 15), // åˆ¤å®šæŒ‰é”®æ˜¯HOLDå¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
  45              // // .press_cnt = 0, // ä¸long_timeå’Œhold_timeå¯¹æ¯”, åˆ¤æ–­é•¿æŒ‰äº‹ä»¶å’ŒHOLDäº‹ä»¶
  46              // // .click_cnt = 0,
  47              // .click_delay_time = 20, // æŒ‰é”®æŠ¬èµ·åï¼Œç­‰å¾…è¿å‡»çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/24/2025 15:43:43 PAGE 2   

  48              // // .notify_value = 0,
  49              // .key_type = KEY_TYPE_AD, // æŒ‰é”®ç±»å‹ä¸ºadæŒ‰é”®
  50              // .get_value = ad_key_get_key_id,
  51          
  52              // .latest_key_val = AD_KEY_ID_NONE,
  53              // .latest_key_event = KEY_EVENT_NONE,
  54          
  55              TOUCH_KEY_SCAN_CIRCLE_TIMES,
  56              0,
  57              // NO_KEY,
  58              0,
  59          
  60              0,
  61              0,
  62              3,
  63          
  64              TOUCH_KEY_LONG_PRESS_TIME_THRESHOLD_MS / TOUCH_KEY_SCAN_CIRCLE_TIMES,
  65              (TOUCH_KEY_LONG_PRESS_TIME_THRESHOLD_MS + TOUCH_KEY_HOLD_PRESS_TIME_THRESHOLD_MS) / TOUCH_KEY_SCAN_CIR
             -CLE_TIMES,
  66              0,
  67          
  68              0,
  69              0,
  70              // 200 / TOUCH_KEY_SCAN_CIRCLE_TIMES,
  71              0,
  72              // NO_KEY,
  73              0,
  74              KEY_TYPE_TOUCH,
  75              touch_key_get_key_id,
  76          
  77              TOUCH_KEY_ID_NONE,
  78              KEY_EVENT_NONE,
  79          };
  80          
  81          static u8 touch_key_get_key_id(void)
  82          {
  83   1          unsigned long tk_key_val = 0;
  84   1          u8 ret = NO_KEY;
  85   1      
  86   1          // delay_ms(1); // å»¶æ—¶å¹¶ä¸èƒ½è§£å†³åˆšä¸Šç‚¹å°±æ£€æµ‹åˆ°é•¿æŒ‰çš„é—®é¢˜
  87   1      
  88   1          // printf("touch key scan\n");
  89   1      
  90   1          tk_key_val = __tk_key_flag;
  91   1      #if 1
  92   1          if (TK_CH9_VALIB == __tk_key_flag)
  93   1          {
  94   2              ret = TOUCH_KEY_ID_1;
  95   2              // return TOUCH_KEY_ID_1;
  96   2          }
  97   1          else if (TK_CH10_VALIB == __tk_key_flag)
  98   1          {
  99   2              ret = TOUCH_KEY_ID_2;
 100   2              // return TOUCH_KEY_ID_2;
 101   2          }
 102   1          else
 103   1          {
 104   2              // return TOUCH_KEY_ID_NONE;
 105   2              // return NO_KEY;
 106   2          }
 107   1      #endif
 108   1      
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/24/2025 15:43:43 PAGE 3   

 109   1      #if 0
                  if (TK_CH10_VALIB == __tk_key_flag)
                  {
                      ret = TOUCH_KEY_ID_2;
                      // return TOUCH_KEY_ID_1;
                  }
                  else if (TK_CH9_VALIB == __tk_key_flag)
                  {
                      ret = TOUCH_KEY_ID_1;
                      // return TOUCH_KEY_ID_2;
                  }
                  else
                  {
                      // return TOUCH_KEY_ID_NONE;
                      // return NO_KEY;
                  }
              #endif
 126   1      
 127   1          tk_key_val = 0;
 128   1      
 129   1          // return __tk_key_flag;        // __tk_key_flag å•æ¬¡æŒ‰é”®æ ‡å¿—
 130   1          return ret;
 131   1      }
 132          
 133          /**
 134           * @brief å°†æŒ‰é”®å€¼å’Œkey_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
 135           *
 136           * @param key_val è§¦æ‘¸æŒ‰é”®é”®å€¼
 137           * @param key_event åœ¨key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
 138           * @return u8 åœ¨touch_key_event_tableä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› TOUCH_KEY_
             -EVENT_NONE
 139           */
 140          static u8 __touch_key_get_event(const u8 key_val, const u8 key_event)
 141          {
 142   1          volatile u8 ret_key_event = TOUCH_KEY_EVENT_NONE;
 143   1          u8 i = 0;
 144   1          for (; i < ARRAY_SIZE(touch_key_event_table); i++)
 145   1          {
 146   2              // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•ˆï¼Œ
             -éœ€è¦æ‰‹åŠ¨ä¿®æ”¹
 147   2              if (key_val == touch_key_event_table[i][0])
 148   2              {
 149   3                  ret_key_event = touch_key_event_table[i][key_event];
 150   3                  break;
 151   3              }
 152   2          }
 153   1      
 154   1          return ret_key_event;
 155   1      }
 156          
 157          void touch_key_handle(void)
 158          {
 159   1          u8 touch_key_event = TOUCH_KEY_EVENT_NONE;
 160   1      
 161   1          if (touch_key_para.latest_key_val == TOUCH_KEY_ID_NONE)
 162   1          {
 163   2              return;
 164   2          }
 165   1      
 166   1          touch_key_event = __touch_key_get_event(touch_key_para.latest_key_val, touch_key_para.latest_key_event
             -);
 167   1          touch_key_para.latest_key_val = TOUCH_KEY_ID_NONE;
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/24/2025 15:43:43 PAGE 4   

 168   1          touch_key_para.latest_key_event = KEY_EVENT_NONE;
 169   1      
 170   1          switch (touch_key_event)
 171   1          {
 172   2          case TOUCH_KEY_EVENT_ID_1_CLICK:
 173   2              // printf("touch key 1 click\n");
 174   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_CLICK_MSG << 16 | TOUCH_KEY_SEND_INFO_1); // DEBUG
             - æµ‹è¯•æ—¶å±è”½ï¼Œåº”è¯¥æ¢å¤
 175   2      
 176   2              // DEBUG
 177   2              // if (fuel_adc_val < 4095 - 100)
 178   2              // {
 179   2              //     fuel_adc_val += 100;
 180   2              // }
 181   2      
 182   2              break;
 183   2      
 184   2          case TOUCH_KEY_EVENT_ID_1_DOUBLE:
 185   2              // printf("touch key 1 double\n");
 186   2              break;
 187   2      
 188   2          case TOUCH_KEY_EVENT_ID_1_LONG:
 189   2              // printf("touch key 1 long\n");
 190   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LONG_MSG << 16 | TOUCH_KEY_SEND_INFO_1);
 191   2              break;
 192   2      
 193   2          case TOUCH_KEY_EVENT_ID_1_HOLD:
 194   2              // printf("touch key 1 hold\n");
 195   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_HOLD_MSG << 16 | TOUCH_KEY_SEND_INFO_1);
 196   2              break;
 197   2      
 198   2          case TOUCH_KEY_EVENT_ID_1_LOOSE:
 199   2              // printf("touch key 1 loose\n");
 200   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LOOSE_MSG << 16 | TOUCH_KEY_SEND_INFO_1);
 201   2              break;
 202   2          case TOUCH_KEY_EVENT_ID_2_CLICK:
 203   2              // printf("touch key 2 click\n");
 204   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_CLICK_MSG << 16 | TOUCH_KEY_SEND_INFO_2); // DEBUG
             - æµ‹è¯•æ—¶å±è”½ï¼Œåº”è¯¥æ¢å¤
 205   2      
 206   2              // DEBUG
 207   2              // if (fuel_adc_val > 100)
 208   2              // {
 209   2              //     fuel_adc_val -= 100;
 210   2              // }
 211   2              break;
 212   2      
 213   2          case TOUCH_KEY_EVENT_ID_2_DOUBLE:
 214   2              // printf("touch key 2 double\n");
 215   2              break;
 216   2      
 217   2          case TOUCH_KEY_EVENT_ID_2_LONG:
 218   2              // printf("touch key 2 long\n");
 219   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LONG_MSG << 16 | TOUCH_KEY_SEND_INFO_2);
 220   2              break;
 221   2      
 222   2          case TOUCH_KEY_EVENT_ID_2_HOLD:
 223   2              // printf("touch key 2 hold\n");
 224   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_HOLD_MSG << 16 | TOUCH_KEY_SEND_INFO_2);
 225   2              break;
 226   2      
 227   2          case TOUCH_KEY_EVENT_ID_2_LOOSE:
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         07/24/2025 15:43:43 PAGE 5   

 228   2              // printf("touch key 2 loose\n");
 229   2              send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LOOSE_MSG << 16 | TOUCH_KEY_SEND_INFO_2);
 230   2              break;
 231   2      
 232   2          default:
 233   2              break;
 234   2          }
 235   1      }
*** WARNING C316 IN LINE 235 OF ..\..\User\touch_key.c: unterminated conditionals


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    304    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     31       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
